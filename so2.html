<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SO2</title>

    <style>
        .show-answer .correct+label {
            color: #09af00;
        }

        .show-answer .wrong+label {
            color: red;
        }
    </style>
</head>

<body>
    <div id="questions-form">

        <fieldset id="0">
            <legend>1. A quanti gruppi può appartenere un utente nel SO Linux?
            </legend>

            <div>
                <input type="radio" id="1_0" name="1" class="correct">
                <label for="1_0">Ad almeno un gruppo</label>
            </div>


            <div>
                <input type="radio" id="1_1" name="1">
                <label for="1_1">Ad un solo gruppo</label>
            </div>


            <div>
                <input type="radio" id="1_2" name="1">
                <label for="1_2">A zero o più gruppi</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="1">
            <legend>2. Si supponga che nel sistema esiste un gruppo "studente" ed anche l'utente "utente1".
                <br>
                Si supponga quindi di eseguire il comando <code>adduser utente1 studente</code>.
                <br>
                Quale delle seguenti affermazioni è sbagliata?
            </legend>

            <div>
                <input type="radio" id="2_0" name="2" class="correct">
                <label for="2_0">Il comando genera un errore perchè per aggiungere un utente ad un gruppo si può
                    utilizzare solo il comando addgroup </label>
            </div>


            <div>
                <input type="radio" id="2_1" name="2">
                <label for="2_1">Se "utente1" non appartiene al gruppo "studente" lo aggiunge a tale gruppo altrimenti
                    non lo aggiunge</label>
            </div>


            <div>
                <input type="radio" id="2_2" name="2">
                <label for="2_2">Aggiunge utente1 al gruppo studente oppure genera un messaggio del tipo L'utente
                    «utente1» fa già parte del gruppo «studente»</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="2">
            <legend>3. Si supponga che nel sistema esiste un gruppo "studente" e non esista ancora l'utente "utente1".
                <br>
                Si supponga quindi di eseguire il comando <code>sudo adduser utente1 studente</code>
                <br>
                Quale sarà il risultato?
            </legend>

            <div>
                <input type="radio" id="3_0" name="3" class="correct">
                <label for="3_0">Da errore perchè utente1 non esiste</label>
            </div>


            <div>
                <input type="radio" id="3_1" name="3">
                <label for="3_1">Crea utente1 e, oltre a creare il gruppo utente1 lo aggiunge al gruppo studente</label>
            </div>


            <div>
                <input type="radio" id="3_2" name="3">
                <label for="3_2">Crea utente1, lo aggiunge al gruppo studente e non crea il gruppo utente1</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="3">
            <legend>4. Supponga di eseguire, come utente sudoer, i seguenti comandi: C1) sudo ls /home, C2) sudo su
                --command=’ls /homè. Quale affermazioneè corretta?
            </legend>

            <div>
                <input type="radio" id="4_0" name="4">
                <label for="4_0">C2 da errore "comando non trovato"</label>
            </div>


            <div>
                <input type="radio" id="4_1" name="4" class="correct">
                <label for="4_1">C1 e C2 sono equivalenti</label>
            </div>


            <div>
                <input type="radio" id="4_2" name="4">
                <label for="4_2">C2 esegue una setUID mentre C1 no</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="4">
            <legend>5. Quale è la differenza tra i comandi sudo e su
            </legend>

            <div>
                <input type="radio" id="5_0" name="5">
                <label for="5_0">sudo è un comando che permette di eseguire altri comandi come root; su è una
                    scorciatoia per invocare il comando sudo</label>
            </div>


            <div>
                <input type="radio" id="5_1" name="5" class="correct">
                <label for="5_1">su è un comando che permette di cambiare utente. sudo è un camando che permette di
                    eseguire altri comandi come super-utente </label>
            </div>


            <div>
                <input type="radio" id="5_2" name="5">
                <label for="5_2">sudo si riferisce ad un gruppo di utenti. su è invece un comando che permette di
                    cambiare utente</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="5">
            <legend>6. Di quante sezioni è composto il man di Linux?
            </legend>

            <div>
                <input type="radio" id="6_0" name="6">
                <label for="6_0">5</label>
            </div>


            <div>
                <input type="radio" id="6_1" name="6">
                <label for="6_1">7</label>
            </div>


            <div>
                <input type="radio" id="6_2" name="6" class="correct">
                <label for="6_2">9</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="6">
            <legend>7. Supponga di voler creare un file vuoto e di voler settare il tempo di ultimo accesso al "2 giugno
                2020 ore 12:00". Quale dei seguenti comandi è corretto?
            </legend>

            <div>
                <input type="radio" id="7_0" name="7" class="correct">
                <label for="7_0">touch -at202006021200 filename</label>
            </div>


            <div>
                <input type="radio" id="7_1" name="7">
                <label for="7_1">touch -cat202006021200 filename</label>
            </div>


            <div>
                <input type="radio" id="7_2" name="7">
                <label for="7_2">touch -ct202006021200 filename</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="7">
            <legend>8. Quale è il risultato del comando touch nomefile?
            </legend>

            <div>
                <input type="radio" id="8_0" name="8">
                <label for="8_0">Crea un file vuoto con nome nomefile</label>
            </div>


            <div>
                <input type="radio" id="8_1" name="8" class="correct">
                <label for="8_1">Aggiorna, al tempo corrente, gli atttributi atime e mtime di nomefile </label>
            </div>


            <div>
                <input type="radio" id="8_2" name="8">
                <label for="8_2">Crea un file vuoto con nome nomefile e ctime uguale al tempo corrente. Se si usa
                    l'opzione -t o -d si può specificare un altro tempo di creazione </label>
            </div>

        </fieldset>
        <br>

        <fieldset id="8">
            <legend>9. I premessi di acceesso della directory /tmp sono <code>1777/drwxrwxrwt</code>
                <br>
                Cosa significa?
            </legend>

            <div>
                <input type="radio" id="9_0" name="9">
                <label for="9_0">Il bit SetGid è settato</label>
            </div>


            <div>
                <input type="radio" id="9_1" name="9">
                <label for="9_1">Lo sticky bit non è settatto</label>
            </div>


            <div>
                <input type="radio" id="9_2" name="9" class="correct">
                <label for="9_2">Lo sticky bit è settato</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="9">
            <legend>10. Supponga di voler mostrare l’albero delle directory con radice dir1 e con profondità 3.
                <br>
                Quale tra i seguenti comandi è il più apprropriato usare?(uscito 2 volte)
            </legend>

            <div>
                <input type="radio" id="10_0" name="10">
                <label for="10_0">tree -d 3 dir1</label>
            </div>


            <div>
                <input type="radio" id="10_1" name="10" class="correct">
                <label for="10_1">tree -L 3 dir1</label>
            </div>


            <div>
                <input type="radio" id="10_2" name="10">
                <label for="10_2">tree --max-depth=3 dir1</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="10">
            <legend>11. Supponiamo vogliate visualizzare l’albero delle directory con radice nella vostra home. In
                particolare volete visualizzare solo le directory e non i file in esse contenuti.
                <br>
                Quali tra i seguenti comandi è il più appropriato?
            </legend>

            <div>
                <input type="radio" id="11_0" name="11" class="correct">
                <label for="11_0">tree -d ~</label>
            </div>


            <div>
                <input type="radio" id="11_1" name="11">
                <label for="11_1">tree -d -L 3 /home/myhomedir</label>
            </div>


            <div>
                <input type="radio" id="11_2" name="11">
                <label for="11_2">tree -a ~</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="11">
            <legend>12. Si supponga di avere un file di testo (filein) e di voler copiare in un altro file (fileout) i
                primi 100 caratteri. Quale di questi comandi è corretto?
            </legend>

            <div>
                <input type="radio" id="12_0" name="12" class="correct">
                <label for="12_0">dd if=filein of=fileout bs=100 count=1</label>
            </div>


            <div>
                <input type="radio" id="12_1" name="12">
                <label for="12_1">dd if=filein of=fileout bs=1 skip=1 count=100</label>
            </div>


            <div>
                <input type="radio" id="12_2" name="12">
                <label for="12_2">dd if=filein of=fileout bs=10 skip=10 count=10</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="12">
            <legend>13. Si supponga di avere un file di testo (filein) contenente 1000 caratteri e di voler copiare in
                un altro file (fileout) 100 caratteri a partire dal decimo. Quale di questi comandi non produce il
                risultato atteso?
            </legend>

            <div>
                <input type="radio" id="13_0" name="13">
                <label for="13_0">dd if=filein of=fileout bs=1 skip=10 count=100</label>
            </div>


            <div>
                <input type="radio" id="13_1" name="13" class="correct">
                <label for="13_1">dd if=filein of=fileout bs=100 seek=10 count=1</label>
            </div>


            <div>
                <input type="radio" id="13_2" name="13">
                <label for="13_2">dd if=filein of=fileout bs=10 skip=1 count=10</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="13">
            <legend>14. Quanti job in background crea il comando seguente?
                <br>
                <code>sleep 30 | sleep 15 | sleep 10 &</code>
            </legend>

            <div>
                <input type="radio" id="14_0" name="14" class="correct">
                <label for="14_0">1</label>
            </div>


            <div>
                <input type="radio" id="14_1" name="14">
                <label for="14_1">Nessuno, da errore</label>
            </div>


            <div>
                <input type="radio" id="14_2" name="14">
                <label for="14_2">3</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="14">
            <legend>15. Quanti file system principali ha linux?
            </legend>

            <div>
                <input type="radio" id="15_0" name="15">
                <label for="15_0">dipende dal numero di filesystem mondati al boot</label>
            </div>


            <div>
                <input type="radio" id="15_1" name="15" class="correct">
                <label for="15_1">1</label>
            </div>


            <div>
                <input type="radio" id="15_2" name="15">
                <label for="15_2">dipende dal numero di dischi installati</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="15">
            <legend>16. In che file è contenuta la lista dei filesystem montati al boot?
            </legend>

            <div>
                <input type="radio" id="16_0" name="16">
                <label for="16_0">/etc/mdev</label>
            </div>


            <div>
                <input type="radio" id="16_1" name="16">
                <label for="16_1">/etc/mtab</label>
            </div>


            <div>
                <input type="radio" id="16_2" name="16" class="correct">
                <label for="16_2">/etc/fstab</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="16">
            <legend>17. Perchè il comando passwd (ovvero il file eseguibile /usr/bin/passwd) ha il SetUID bit settato?
            </legend>

            <div>
                <input type="radio" id="17_0" name="17" class="correct">
                <label for="17_0">Per consentire a qualsiasi utente di modificare la propria password</label>
            </div>


            <div>
                <input type="radio" id="17_1" name="17">
                <label for="17_1">Per evitare che un utente possa cancellare il file eseguibile passwd</label>
            </div>


            <div>
                <input type="radio" id="17_2" name="17">
                <label for="17_2">Per evitare che un utente possa modificare le password degli altri utenti</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="17">
            <legend>18. Supponiamo di avere il seguente makefile (memorizzato in un file di nome makefile):
                <br>
                <pre>merge_sorted_lists: merge_sorted_lists.c
<br>
gcc -Wall -Wextra -O3 merge_sorted_lists.c -o merge_sorted_lists
<br>
sort_file_int: sort_file_int.c
<br>
gcc -Wall -Wextra -O3 sort_file_int.c -o sort_file_int
<br>
.PHONY: clean
<br>
clean:
<br>
rm -f *.o merge_sorted_lists</pre>
                <br>
                supponendo che non esistono entrambi i file merge_sorted_lists e sort_file_int e lanciando il comando
                make, quale target viene eseguito?
                <br>
                <b>Adesso posso scrivere in bold con l'HTML nelle domande yeee</b>
            </legend>

            <div>
                <input type="radio" id="18_0" name="18" class="correct">
                <label for="18_0">merge_sorted_list</label>
            </div>


            <div>
                <input type="radio" id="18_1" name="18">
                <label for="18_1">entrambi</label>
            </div>


            <div>
                <input type="radio" id="18_2" name="18">
                <label for="18_2">nessuno dei due. Va specificato quale vogliamo eseguire con il comando make
                    <nome_target></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="18">
            <legend>19. Assumiamo di compilare un file .c nei seguenti modi
                <br>
                <pre>gcc file.c -o file1.o
<br>
gcc -g file.c -o file2.o
<br>
</pre>
                <br>
                Perchè le dimensioni di file2.o sono diverse da quelle di file1.o?
            </legend>

            <div>
                <input type="radio" id="19_0" name="19">
                <label for="19_0">perchè file2.o è stato ottimizzato, per occupare meno spazio in memoria, rispetto a
                    file1.o</label>
            </div>


            <div>
                <input type="radio" id="19_1" name="19" class="correct">
                <label for="19_1">perchè file2.o contiene informazioni aggiuntive rispetto a file1.o utili per il
                    debug</label>
            </div>


            <div>
                <input type="radio" id="19_2" name="19">
                <label for="19_2">non è vero che i due comandi di compilazione producono file di dimensioni
                    diverse</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="19">
            <legend>20. Assuma di avere due shell aperte, etichettate come shell_1 e shell_2 e supponga di eseguire la
                sequenza di comandi che segue
                <br>
                (shell_i: cmd indica che cmd è eseguitto nella shell_i, i=1,2).
                <br>
                <pre>shell_1: xterm
<br>
shell_2: ps -C xterm
<br>
#restituisce xtermPID
<br>
shell_2: kill -s SIGSTOP xtermPID
<br>
shell_2: kill -s SIGCONT xtermPID</pre>
                <br>
                Quale è il loro effetto su processo xterm?
            </legend>

            <div>
                <input type="radio" id="20_0" name="20">
                <label for="20_0">Il processo xterm viene prima mandato in esecuzione in background e poi riportato in
                    foreground</label>
            </div>


            <div>
                <input type="radio" id="20_1" name="20" class="correct">
                <label for="20_1">Il processo xterm viene mandato in esecuzione in background </label>
            </div>


            <div>
                <input type="radio" id="20_2" name="20">
                <label for="20_2">Il processo xterm viene prima portato nello stato stopped (T) e poi mandato in
                    esecuzione in foreground</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="20">
            <legend>21. Si assuma di avere due shell aperte, etichettate come shell_1 e shell_2 e si consideri la
                seguente sequenza di comandi
                <br>
                (shell_i:cmd indica che cmd è eseguitto nella shell i, i=1,2)
                <br>
                <pre>shell_1: xterm
<br>
shell_2: ps -C xterm
<br>
#restituisce xtermPID
<br>
shell_2: kill -s SIGSTOP xtermPID</pre>
                <br>
                Quale è il loro effetto?
            </legend>

            <div>
                <input type="radio" id="21_0" name="21">
                <label for="21_0">Il processo xterm viene terminato con segnale SIGSTOP</label>
            </div>


            <div>
                <input type="radio" id="21_1" name="21">
                <label for="21_1">Il processo xterm viene mandato in esecuzione in background</label>
            </div>


            <div>
                <input type="radio" id="21_2" name="21" class="correct">
                <label for="21_2">Il processo xterm viene messo in stato stopped (T)</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="21">
            <legend>22. Supponga di avere 2 file hw1.c e hw2.c contenenti il seguente codice(uscita 2 volte)
                <br>
                hw1.c:
                <br>
                <pre>#include <stdio.h>
<br>
#include "hw2.c"
<br>
int f(int argc, char *args[]) {
<br>
  printf("Hello World!
<br>
");
<br>
  return 256;
<br>
}
<br>
</pre>
                <br>
                hw2.c:
                <pre>
<br>
int f(int argc, char *args[]);
<br>
int main(int argc, char *args[]) {
<br>
  return f(argc, args);
<br>
}
<br>
</pre>
                <br>
                Quale dei seguenti comandi di compilazione genera errore?
            </legend>

            <div>
                <input type="radio" id="22_0" name="22">
                <label for="22_0">gcc -Wall hw1.c -o hw.out</label>
            </div>


            <div>
                <input type="radio" id="22_1" name="22" class="correct">
                <label for="22_1">gcc -Wall hw1.c hw2.c -o hw.out</label>
            </div>


            <div>
                <input type="radio" id="22_2" name="22">
                <label for="22_2">gcc hw1.c</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="22">
            <legend>23. Supponiamo di avere il file eseguibile (ottenuto dalla compilazione di una programma C)
                mioprogramma
                <br>
                Questi due modi di invocare il programma sono equivalenti?
                <br>
                <code>$ ./mioprogramma A B C</code>
                <br>
                <code>$ ./mioprogramma < input.txt</code>
                <br>
                dove input.txt contiene A B C
            </legend>

            <div>
                <input type="radio" id="23_0" name="23" class="correct">
                <label for="23_0">no, nel primo caso A B C vengono caricati in argv, nel secondo caso vengono inviati
                    sullo stdin</label>
            </div>


            <div>
                <input type="radio" id="23_1" name="23">
                <label for="23_1">dipende dalla logica del codice</label>
            </div>


            <div>
                <input type="radio" id="23_2" name="23">
                <label for="23_2">si sono equivalenti</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="23">
            <legend>24. Quale è la differenza tra thread posix e processo linux (uscito 2 volte)
            </legend>

            <div>
                <input type="radio" id="24_0" name="24">
                <label for="24_0">Thread concorrenti condividono codice, segmento dati e file; i processi concorrenti
                    pure</label>
            </div>


            <div>
                <input type="radio" id="24_1" name="24">
                <label for="24_1">Thread concorrenti condividono lo stack; i processi concorrenti anche</label>
            </div>


            <div>
                <input type="radio" id="24_2" name="24" class="correct">
                <label for="24_2">Thread concorrenti condividono codice, segmento dati e file; i processi concorrenti
                    no</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="24">
            <legend>25. Per mostare il pid dei job in esecuzione in backgroud quali di questi comandi è corretto?
            </legend>

            <div>
                <input type="radio" id="25_0" name="25" class="correct">
                <label for="25_0">jobs -p</label>
            </div>


            <div>
                <input type="radio" id="25_1" name="25">
                <label for="25_1">ps -p -u</label>
            </div>


            <div>
                <input type="radio" id="25_2" name="25">
                <label for="25_2">jobs</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="25">
            <legend>26. Quale di queste stringhe non e’ valida come identificatore in C?
            </legend>

            <div>
                <input type="radio" id="26_0" name="26">
                <label for="26_0">_voltage</label>
            </div>


            <div>
                <input type="radio" id="26_1" name="26">
                <label for="26_1">rerun</label>
            </div>


            <div>
                <input type="radio" id="26_2" name="26" class="correct">
                <label for="26_2">x-axis</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="26">
            <legend>27. Quale di queste stringe e’ valida come identificatore in C?
            </legend>

            <div>
                <input type="radio" id="27_0" name="27" class="correct">
                <label for="27_0">_voltage</label>
            </div>


            <div>
                <input type="radio" id="27_1" name="27">
                <label for="27_1">x-ray</label>
            </div>


            <div>
                <input type="radio" id="27_2" name="27">
                <label for="27_2">return</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="27">
            <legend>28. Si consideri la seguente funzione f
                <br>
                <pre>char *f(char *a, const char *b, size_t n) {
<br>
    size_t i;
<br>
    for (i = 0; i < n && b[i] != ' '; i++)
<br>
        a[i] = b[i];
<br>
    for ( ; i < n; i++)
<br>
           a[i] = ' ';
<br>
        return a;
<br>
}</pre>
                <br>
                Cosa produce come risultato quando eseguita?
            </legend>

            <div>
                <input type="radio" id="28_0" name="28">
                <label for="28_0">Copia esattamente n caratteri della stringa b nella stringa a e restituisce a</label>
            </div>


            <div>
                <input type="radio" id="28_1" name="28">
                <label for="28_1">Concatena al piò n caratteri della stringa b alla stringa a e restituisce a</label>
            </div>


            <div>
                <input type="radio" id="28_2" name="28" class="correct">
                <label for="28_2">Copia al piò n caratteri della stringa b nella stringa a e restituisce a</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="28">
            <legend>29. Si consideri la seguente funzione f
                <br>
                <pre>char *f(char *a, const char *b, size_t n) {
<br>
    size_t l = strlen(a);
<br>
    size_t i;
<br>
    for (i = 0 ; i < n && b[i] != ' ' ; i++)
<br>
        a[l + i] = b[i];
<br>
    a[l + i] = ' ';
<br>
return a;
<br>
}</pre>
                <br>
                Cosa produce come risultato quando eseguita?
            </legend>

            <div>
                <input type="radio" id="29_0" name="29">
                <label for="29_0">Copia al piò n caratteri della stringa b in a e restituisce a</label>
            </div>


            <div>
                <input type="radio" id="29_1" name="29">
                <label for="29_1">Copia esattamente n caratteri della stringa b nella stringa a e restituisce a</label>
            </div>


            <div>
                <input type="radio" id="29_2" name="29" class="correct">
                <label for="29_2">Concatena i primi n caratteri della stringa b alla stringa a e restituisce a</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="29">
            <legend>30. Si consideri la seguente dichiarazione di struttura
                <br>
                <pre>struct point2D {
<br>
    double x; // coordinata x
<br>
    double y; // coordinata y
<br>
}  pA={0, 0}, pB={1, 5};</pre>
                <br>
                Quale delle seguenti assegnazioni e’ corretta?
            </legend>

            <div>
                <input type="radio" id="30_0" name="30">
                <label for="30_0">pA -> x = pB -> x; pA -> y = pB -> y;</label>
            </div>


            <div>
                <input type="radio" id="30_1" name="30">
                <label for="30_1">pA = &pB</label>
            </div>


            <div>
                <input type="radio" id="30_2" name="30" class="correct">
                <label for="30_2">pA = pB;</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="30">
            <legend>31. Si consideri il seguente ciclo for
                <br>
                <pre>int scoreCount, a;
<br>
for(scoreCount=0; scanf("%d",&a)==1; scoreCount++);</pre>
                <br>
                Cosa produrebbe come risultato, se eseguito?
            </legend>

            <div>
                <input type="radio" id="31_0" name="31">
                <label for="31_0">Legge una sola volta da stdin e poi termina, qualunque sia l'input</label>
            </div>


            <div>
                <input type="radio" id="31_1" name="31">
                <label for="31_1">Legge da stdin senza mai terminare</label>
            </div>


            <div>
                <input type="radio" id="31_2" name="31" class="correct">
                <label for="31_2">Legge ripetutamente numeri interi da stdin fintanto che è fornito un input di tipo
                    diverso (ad esempio un carattere)</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="31">
            <legend>32. Consideri il seguente frammento di codice
                <br>
                <pre>int *ptr = malloc(sizeof(int));
<br>
ptr = ptr+1;</pre>
                <br>
                assumendo la malloc assegni a ptr la locazione di memoria 0x55c2b1268420 cosa contiene ptr dopo
                l’incremento?
            </legend>

            <div>
                <input type="radio" id="32_0" name="32">
                <label for="32_0"><code>0x55c2b1268421</code></label>
            </div>


            <div>
                <input type="radio" id="32_1" name="32">
                <label for="32_1">l'incremento della variabile prt genera un errore di segmentazione in fase di
                    esecuzione</label>
            </div>


            <div>
                <input type="radio" id="32_2" name="32" class="correct">
                <label for="32_2"><code>0x55c2b1268424</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="32">
            <legend>33. Cosa stampa su stdout la seguente chiamata a printf?
                <br>
                <code>printf("aaaaa
<br>
bbbbb
</fieldset>
<br>

<fieldset id="33"><legend>ccccc
</fieldset>
<br>

<fieldset id="34"><legend>ddddd
<br>
eeeee
<br>
");</code>
            </legend>

            <div>
                <input type="radio" id="35_0" name="35" class="correct">
                <label for="35_0">aaaaa bbbbb ccccc eeeee</label>
            </div>


            <div>
                <input type="radio" id="35_1" name="35">
                <label for="35_1">aaaaa bbbbb ccccc ddddd</label>
            </div>


            <div>
                <input type="radio" id="35_2" name="35">
                <label for="35_2">aaaaa bbbbb ccccc ddddd eeeee</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="35">
            <legend>34. Si consideri il seguente frammento di codice
                <br>
                <pre>char **mptr, **mptr1, *ptr1;
<br>
int i;
<br>
mptr = calloc(10,sizeof(char *));
<br>
mptr1 = mptr;
<br>
for(i=0;i<10;i++){
<br>
    mptr[i]=(char *)malloc(10);    
<br>
}</pre>
                <br>
                Per de-allocare tutta la memoria allocata, quale delle seguenti opzioni e’ coretta?
            </legend>

            <div>
                <input type="radio" id="36_0" name="36">
                <label for="36_0">for(i=0;i<10;i++) free(mptr1[i]);</label>
            </div>


            <div>
                <input type="radio" id="36_1" name="36" class="correct">
                <label for="36_1">for(i=0;i<10;i++) free(mptr1[i]); free(mptr1);</label>
            </div>


            <div>
                <input type="radio" id="36_2" name="36">
                <label for="36_2">free(mptr1);</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="36">
            <legend>35. Si consideri il seguente frammento di codice
                <br>
                <pre>char **mptr, *ptr1;
<br>
int i;
<br>
mptr = calloc(10,sizeof(char *));
<br>
for(i=0;i<10;i++){
<br>
    mptr[i]=(char *)malloc(10);    
<br>
}</pre>
                <br>
                Quale delle seguenti strategie di de-allocazione crea un memory leakage?
            </legend>

            <div>
                <input type="radio" id="37_0" name="37">
                <label for="37_0">free(mptr);</label>
            </div>


            <div>
                <input type="radio" id="37_1" name="37">
                <label for="37_1">for(i=0;i<10;i++) free(mptr[i]);</label>
            </div>


            <div>
                <input type="radio" id="37_2" name="37" class="correct">
                <label for="37_2">entrambe, ovvero sia (1) che (2)</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="37">
            <legend>36. Si consideri un file contenente un programma in linguaggio C. Si assuma che è stata inserita la
                direttiva #include "stdio.h" . Perchè la compilazione potrebbe generare errori?
            </legend>

            <div>
                <input type="radio" id="38_0" name="38" class="correct">
                <label for="38_0">Perchè cerca il file "stdio.h" nella directory corrente</label>
            </div>


            <div>
                <input type="radio" id="38_1" name="38">
                <label for="38_1">La compilazione non genera errori a meno che il file non esista nel filesystem</label>
            </div>


            <div>
                <input type="radio" id="38_2" name="38">
                <label for="38_2">Perchè il file stdio.h potrebbe non esistere</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="38">
            <legend>37. Quale delle seguenti dichiarazioni di variabile inizializza una stringa?
            </legend>

            <div>
                <input type="radio" id="39_0" name="39">
                <label for="39_0"><code>char r[10] = {`L´,`9´,` ´,`4´,`a´,`p`,`r´};</code></label>
            </div>


            <div>
                <input type="radio" id="39_1" name="39" class="correct">
                <label for="39_1"><code>char r[] = ``L9 4apr´´;</code></label>
            </div>


            <div>
                <input type="radio" id="39_2" name="39">
                <label for="39_2"><code>char r[] = {`L´,`9´,` ´,`4´,`a´,`p`,`r´};</code> </label>
            </div>

        </fieldset>
        <br>

        <fieldset id="39">
            <legend>38. Quale è il modo corretto per controllare che due stringhe str1 e str2 sono uguali?
                <br>
                <code>if strcmp(s1,s2)==0 { printf("stringhe uguali") }</code>
                <br>
                <code>if (s1==s2) { printf("stringhe uguali") }</code>
                <br>
                <code>if strcmp(s1,s2) { printf("stringhe uguali") }</code>
        </fieldset>
        <br>

        <fieldset id="40">
            <legend>39. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
FILE * pFile;
<br>
pFile = open("myfile.txt","rw+");
<br>
fprintf(pFile, "%f %s", 3.1416, "PI");
<br>
</pre>
                <br>
                Assumendo che myfile.txt non esiste, quale delle seguenti affermazioni e’ vera?
            </legend>

            <div>
                <input type="radio" id="41_0" name="41" class="correct">
                <label for="41_0">Il programma genera un errore in fase di esecuzione</label>
            </div>


            <div>
                <input type="radio" id="41_1" name="41">
                <label for="41_1">Il programma genera errore in fase di compilazione</label>
            </div>


            <div>
                <input type="radio" id="41_2" name="41">
                <label for="41_2">Il programma scrive sul file myfile.txt la stringa 3.1416 PI</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="41">
            <legend>40. Cosa fa il seguente segmento di codice se eseguito?
                <br>
                <pre>scanf(“%d",&num); 
<br>
do; {
<br>
printf(“%d
<br>
",num); 
<br>
scanf(“%d",&num);
<br>
}  while(num!=0);</pre>
            </legend>

            <div>
                <input type="radio" id="42_0" name="42">
                <label for="42_0">Stampa il valore di num almeno una volta</label>
            </div>


            <div>
                <input type="radio" id="42_1" name="42">
                <label for="42_1">Cicla infinitamente se num e’ diverso da 0</label>
            </div>


            <div>
                <input type="radio" id="42_2" name="42">
                <label for="42_2">Popipopi S.p.A. > CD Click s.r.l.</label>
            </div>


            <div>
                <input type="radio" id="42_3" name="42" class="correct">
                <label for="42_3">Genera errore in fase di compilazione</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="42">
            <legend>41. Si consideri il frammento di codice
                <br>
                <pre>i=0; c=0; p=1;
<br>
while (i++ < 10)
<br>
c=c+1;
<br>
p--;</pre>
                <br>
                che valore conterrà p al termine dell'esecuzione del frammento di codice?
            </legend>

            <div>
                <input type="radio" id="43_0" name="43" class="correct">
                <label for="43_0">0</label>
            </div>


            <div>
                <input type="radio" id="43_1" name="43">
                <label for="43_1">-10</label>
            </div>


            <div>
                <input type="radio" id="43_2" name="43">
                <label for="43_2">-9</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="43">
            <legend>42. Supponiamo di eseguire separatamente i seguenti frammenti di codice
                <br>
                <b>Frammento_1</b>
                <br>
                <pre>close(2);
<br>
if (fopen(".","r")) {
<br>
           perror("main");
<br>
}</pre>
                <br>
                <b>Frammento_2</b>
                <br>
                <pre>close(2);
<br>
if (fopen(".","r")) {
<br>
               printf("main: %s 
<br>
", strerror(errno));
<br>
}</pre>
                <br>
                Quale delle seguenti affermazioni è falsa?
            </legend>

            <div>
                <input type="radio" id="44_0" name="44">
                <label for="44_0">Il frammento_1 non produce alcun output sul terminale</label>
            </div>


            <div>
                <input type="radio" id="44_1" name="44" class="correct">
                <label for="44_1">La loro esecuzione produce sul terminale due stringhe identiche</label>
            </div>


            <div>
                <input type="radio" id="44_2" name="44">
                <label for="44_2">Il frammento_2 produce un output sullo stdout</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="44">
            <legend>43. Consideriamo queste due line di codice
                <br>
                1. <code>printf("main:%s
<br>
",strerror(errno));</code>
                <br>
                2. <code>perror("main");</code>
                <br>
                Quali delle seguenti affermazioni è corretta?
            </legend>

            <div>
                <input type="radio" id="45_0" name="45">
                <label for="45_0">Producono stringhe diverse e la prima la invia su stdout mentre la seconda su
                    stderr.</label>
            </div>


            <div>
                <input type="radio" id="45_1" name="45">
                <label for="45_1">Inviano la stessa stringa su stdout</label>
            </div>


            <div>
                <input type="radio" id="45_2" name="45" class="correct">
                <label for="45_2">producono la stessa stringa ma la 1 la invia su stdout, mentre la 2 su stderr </label>
            </div>

        </fieldset>
        <br>

        <fieldset id="45">
            <legend>44. Quale delle seguenti funzioni di libreria alloca memoria nello stack?
            </legend>

            <div>
                <input type="radio" id="46_0" name="46">
                <label for="46_0">void *calloc( size_t nmemb, size_t size );</label>
            </div>


            <div>
                <input type="radio" id="46_1" name="46" class="correct">
                <label for="46_1">void *alloca( size_t size );</label>
            </div>


            <div>
                <input type="radio" id="46_2" name="46">
                <label for="46_2">void *malloc( size_t size );</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="46">
            <legend>45. Un processo può allocare memoria nello stack?
            </legend>

            <div>
                <input type="radio" id="47_0" name="47">
                <label for="47_0">no un processo può allocare memoria sono nell'heap</label>
            </div>


            <div>
                <input type="radio" id="47_1" name="47">
                <label for="47_1">si mediante la funziona di libreria malloc(3)</label>
            </div>


            <div>
                <input type="radio" id="47_2" name="47" class="correct">
                <label for="47_2">si mediante la funzione di libreria alloca(3) </label>
            </div>

        </fieldset>
        <br>

        <fieldset id="47">
            <legend>46. Quale e’ la differenza tra la system call _exit(2) e la funzione di libreria exit(3)? (uscita 2
                volte)
            </legend>

            <div>
                <input type="radio" id="48_0" name="48">
                <label for="48_0">_exit(2) chiude tutti i file descriptor mentre exit(3) no</label>
            </div>


            <div>
                <input type="radio" id="48_1" name="48" class="correct">
                <label for="48_1">_exit(2) non invoca gli handler registrati con atexit e on_exit mentre exit(3) li
                    invoca</label>
            </div>


            <div>
                <input type="radio" id="48_2" name="48">
                <label for="48_2">_exit(2) invoca gli handler registrati con atexit e on_exit mentre exit(3) non li
                    invoca</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="48">
            <legend>47. Quale attributi di un processo sono ereditati dal processo figlio?
            </legend>

            <div>
                <input type="radio" id="49_0" name="49">
                <label for="49_0">parent pid, timer, contatori risorse </label>
            </div>


            <div>
                <input type="radio" id="49_1" name="49" class="correct">
                <label for="49_1">working directory, descrittori dei file, memoria condivisa</label>
            </div>


            <div>
                <input type="radio" id="49_2" name="49">
                <label for="49_2">timer, lock, coda dei segnali</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="49">
            <legend>48. Si consideri il seguente frammento di codice
                <br>
                <pre>pid_t pID = fork();
<br>
if (pID == 0) {
<br>
    Blocco_1
<br>
} else if (pID < 0) {
<br>
    Blocco_2
<br>
} else {
<br>
  Blocco_3
<br>
}</pre>
                <br>
                Quale blocco di codice (tra Bloccco_1, Blocco_2 e Blocco_3) verrà eseguito dal processo figlio?
            </legend>

            <div>
                <input type="radio" id="50_0" name="50">
                <label for="50_0">Blocco_3</label>
            </div>


            <div>
                <input type="radio" id="50_1" name="50" class="correct">
                <label for="50_1">Blocco_1</label>
            </div>


            <div>
                <input type="radio" id="50_2" name="50">
                <label for="50_2">Blocco_2</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="50">
            <legend>49. Si consideri il seguente frammento di codice
                <br>
                <pre>pid_t pID = fork();
<br>
if (pID == 0) {
<br>
    Blocco_1
<br>
} else if (pID < 0) {
<br>
    Blocco_2
<br>
} else {
<br>
  Blocco_3
<br>
}</pre>
                <br>
                Quale blocco di codice (tra Bloccco_1, Blocco_2 e Blocco_3) verrà eseguito dal processo padre?
            </legend>

            <div>
                <input type="radio" id="51_0" name="51" class="correct">
                <label for="51_0">Blocco_3</label>
            </div>


            <div>
                <input type="radio" id="51_1" name="51">
                <label for="51_1">Blocco_1</label>
            </div>


            <div>
                <input type="radio" id="51_2" name="51">
                <label for="51_2">Blocco_2</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="51">
            <legend>50. Supponiamo che la system call
                <br>
                <code>pid_t waitpid(pid_t pid, int *status, int options);</code>
                <br>
                sia invocata con valore di pid uguale a 0. Quale è il suo comportamento?
                <br>
                Scegli un'alternativa:
            </legend>

            <div>
                <input type="radio" id="52_0" name="52">
                <label for="52_0">attende la terminazione di qualunque processo figlio il cui gruppo ID del processo sia
                    diverso da quello del processo chiamante</label>
            </div>


            <div>
                <input type="radio" id="52_1" name="52" class="correct">
                <label for="52_1">attende la terminazione di qualunque processo figlio il cui gruppo ID sia uguale a
                    quello del processo chiamante (ovvero il processo padre)</label>
            </div>


            <div>
                <input type="radio" id="52_2" name="52">
                <label for="52_2">attende la terminazione di qualunque processo figlio</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="52">
            <legend>51. Si consideri il seguente frammento di codice (i numeri a lato sono i numeri di riga delle
                istruzioni)(uscita 2 volte)
                <br>
                <pre>1.    Pthread_t tid;
<br>
2.    pthread_create(&tid, ... )
<br>
3.    pthread_create(&tid, ...)
<br>
4.    pthread_join(tid, ...);
<br>
5.    printf("joined");</pre>
                <br>
                quale delle seguenti affermazioni e’ falsa?
            </legend>

            <div>
                <input type="radio" id="53_0" name="53">
                <label for="53_0">la stringa "joined" è inviata su stdout solo quando il thread creato a riga 3 è
                    terminato</label>
            </div>


            <div>
                <input type="radio" id="53_1" name="53" class="correct">
                <label for="53_1">la stringa "joined" è inviata su stdout quando entrambi i thread sono
                    terminati</label>
            </div>


            <div>
                <input type="radio" id="53_2" name="53">
                <label for="53_2">la chiamata pthread_join(...) attende la terminazione del thread con identificatore
                    tid</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="53">
            <legend>52. Si considerino i seguenti frammenti di codice (R1 e R2)
                <br>
                <pre>R1: strPtr=(char *) calloc(SIZE_OF_ARRAY, sizeof(char) );
<br>
R2: strPtr=(char *) malloc(SIZE_OF_ARRAY);
<br>
    memset(strPtr, ´ ´, SIZE_OF_ARRAY);</pre>
            </legend>

            <div>
                <input type="radio" id="54_0" name="54" class="correct">
                <label for="54_0">R1 e R2 producono lo stesso risultato</label>
            </div>


            <div>
                <input type="radio" id="54_1" name="54">
                <label for="54_1">R2 dopo aver allocato la memoria la inizializza, mentre R1 no</label>
            </div>


            <div>
                <input type="radio" id="54_2" name="54">
                <label for="54_2">R1 alloca nell’heap, e quindi dopo e’ consigliabile “pulire" la memoria; mentre R2
                    alloca nello stack e quindi non c’e’ bisogno di “pulire" la memoria.</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="54">
            <legend>53. Consideriamo la seguente invocazione della funzione realloc
                <br>
                <code>strptr1=(char *) realloc(strptr, 10 * SIZE_OF_ARRAY);</code>
                <br>
                strptr1 può essere diverso da strptr?
            </legend>

            <div>
                <input type="radio" id="55_0" name="55">
                <label for="55_0">si, la realloc modifica sempre l'indirizzo di partenza dell'area di memoria
                    ridimensionata</label>
            </div>


            <div>
                <input type="radio" id="55_1" name="55">
                <label for="55_1">no, strptr1 è sempre uguale a strptr</label>
            </div>


            <div>
                <input type="radio" id="55_2" name="55" class="correct">
                <label for="55_2">sì se a seguito del ridimensionamento della memoria allocata non è possibile trovare
                    un numero sufficiente di locazioni contigue a partire dal strptr </label>
            </div>

        </fieldset>
        <br>

        <fieldset id="55">
            <legend>54. Supponiamo di voler modificare il comportamento di default di un processo quando esso riceve un
                segnale. Ovvero vogliamo modificare il gestore (handler) di un segnale.
                <br>
                Quale, tra le system call, o combinazione di system call di seguito riportate e’ possibile utilizzare?
            </legend>

            <div>
                <input type="radio" id="56_0" name="56" class="correct">
                <label for="56_0">sigaction(2)</label>
            </div>


            <div>
                <input type="radio" id="56_1" name="56">
                <label for="56_1">sigaction(2) seguita da una fork(2) che esegue l’handler del segnale</label>
            </div>


            <div>
                <input type="radio" id="56_2" name="56">
                <label for="56_2">signal(2) seguita da una fork(2) che esegue l’handler del segnale</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="56">
            <legend>55. Assumiamo di voler settare i permessi di accesso 0600 al file filename mediante l'uso della
                system call open(2). Quale delle seguenti chiamate è corretta?
            </legend>

            <div>
                <input type="radio" id="57_0" name="57">
                <label for="57_0">open( "filename", O_RDWR | O_CREAT | S_IRUSR | S_IWUSR);</label>
            </div>


            <div>
                <input type="radio" id="57_1" name="57">
                <label for="57_1">open("filename",O_RDWR | O_CREAT, S_IRUSR & S_IWUSR);</label>
            </div>


            <div>
                <input type="radio" id="57_2" name="57" class="correct">
                <label for="57_2">open( "filename", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="57">
            <legend>56. Si consideri la system call
                <br>
                <pre>int open(const char *pathname, int flags);
<br>
nel caso venga invocata con il flag impostato a
<br>
O_CREAT | O_EXCL | O_RDONLY</pre>
                <br>
                Quale è il comportamento atteso?
            </legend>

            <div>
                <input type="radio" id="58_0" name="58" class="correct">
                <label for="58_0">Se il file non esiste viene creato ed aperto in lettura, se invece esiste ritorna
                    errore</label>
            </div>


            <div>
                <input type="radio" id="58_1" name="58">
                <label for="58_1">Se il file non esiste lo crea e lo apre in lettura, altrimenti lo apre in
                    lettura</label>
            </div>


            <div>
                <input type="radio" id="58_2" name="58">
                <label for="58_2">Se il file non esiste viene creato con i permessi di esecuzione (x) ed aperto in
                    lettura. Se esiste vengono aggiunti i permessi di esecuzione se già non settati ed il file è aperto
                    in lettura</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="58">
            <legend>57. Si consideri il seguente frammento di codice
                <br>
                <pre>char* file = argv[1];
<br>
int fd;
<br>
struct flock lock;
<br>
fd = open (file, O_WRONLY);
<br>
memset (&lock, 0, sizeof(lock));
<br>
lock.l_type = F_WRLCK;
<br>
fcntl (fd, F_SETLKW, &lock);
<br>
....</pre>
                <br>
                Quale è il suo comportamento?
            </legend>

            <div>
                <input type="radio" id="59_0" name="59">
                <label for="59_0">mette un lock mandatory in scrittura sul file file</label>
            </div>


            <div>
                <input type="radio" id="59_1" name="59">
                <label for="59_1">mette un lock advisory in scrittura sul file file</label>
            </div>


            <div>
                <input type="radio" id="59_2" name="59" class="correct">
                <label for="59_2">mette un lock bloccante in scrittura sul file file.</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="59">
            <legend>58. Quale è la differenza tra i seguenti frammenti di codice?
                <br>
                <pre>C1: int fd, fd1;
<br>
    fd=open(“filename", O_RDWR);
<br>
    fd1=fd;
<br>
</pre>
                <br>
                <pre>C2: int fd,fd1;
<br>
    fd=open(“filename", O_RDWR);
<br>
    fd1=dup(fd);</pre>
            </legend>

            <div>
                <input type="radio" id="60_0" name="60">
                <label for="60_0">Dopo l’esecuzione di C1 e C2 fd1 contiene lo stesso valore</label>
            </div>


            <div>
                <input type="radio" id="60_1" name="60">
                <label for="60_1">Dopo l’esecuzione di C1 i due file descriptor puntano allo stesso file, mentre dopo
                    l’esecuzione di C2 il file filename viene duplicato</label>
            </div>


            <div>
                <input type="radio" id="60_2" name="60" class="correct">
                <label for="60_2">Dopo l’eseccuzione di C1 fd1 contiene lo stesso valore di fd; mentre dopo l’esecuzione
                    di C2 fd1 contiene il valore del piu’ piccolo file descriptor disponibile</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="60">
            <legend>59. Si consideri il seguente frammento di codice
                <br>
                <pre>int fd,fd1;
<br>
struct stat buf,
<br>
buf1;
<br>
fd=open(“filename", O_RDWR);
<br>
fd1=dup(fd); 
<br>
fstat(fd,&buf);
<br>
fstat(fd1,&buf1);</pre>
            </legend>

            <div>
                <input type="radio" id="61_0" name="61" class="correct">
                <label for="61_0">buf.st_ino è uguale a buf1.st_ino</label>
            </div>


            <div>
                <input type="radio" id="61_1" name="61">
                <label for="61_1">buf.st_ino e’ diverso da buf1.st_ino</label>
            </div>


            <div>
                <input type="radio" id="61_2" name="61">
                <label for="61_2">st_ino non e’ membro della struttura stat</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="61">
            <legend>60. Supponiamo di avere il seguente frammento di codice
                <br>
                <pre>struct dirent *dentry; //directory stream
<br>
    char *filename;
<br>
    DIR *dstr=opendir(“mydir");
<br>
    while ((dentry=readdir(dstr)) != NULL) {
<br>
        /* Memorizzai nome file nella  directory  in filename  */
<br>
         }</pre>
                <br>
                Quale delle seguenti istruzioni deve essere posta all’interno del ciclo while per memorizzare in
                filename il nome dei file contenuti all’interno della directory mydir ?
            </legend>

            <div>
                <input type="radio" id="62_0" name="62" class="correct">
                <label for="62_0">filename = dentry --> d_name;</label>
            </div>


            <div>
                <input type="radio" id="62_1" name="62">
                <label for="62_1">filename = dentry.filename;</label>
            </div>


            <div>
                <input type="radio" id="62_2" name="62">
                <label for="62_2">filename = dentry --> filename;</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="62">
            <legend>61. Quali attributi di processo sono preservati dalla system call execve(2)?
            </legend>

            <div>
                <input type="radio" id="63_0" name="63">
                <label for="63_0">Memory locks</label>
            </div>


            <div>
                <input type="radio" id="63_1" name="63">
                <label for="63_1">Timer</label>
            </div>


            <div>
                <input type="radio" id="63_2" name="63" class="correct">
                <label for="63_2">Umask</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="63">
            <legend>62. Si consideri la system call execve(2). Quale delle seguenti affermazioni è corretta?
            </legend>

            <div>
                <input type="radio" id="64_0" name="64">
                <label for="64_0">la execve(2) permette di generare un proccesso figlio del processo chiamante senza
                    utilizzare una fork ma semplicemente eseguendo un immagine contenuta in un file (execve esegue
                    implicitamente la fork)</label>
            </div>


            <div>
                <input type="radio" id="64_1" name="64" class="correct">
                <label for="64_1">la execve(2) permette di sostituire l'immagine di un processo con quella di un file
                    eseguibile o di uno script di shell eseguibile</label>
            </div>


            <div>
                <input type="radio" id="64_2" name="64">
                <label for="64_2">la execve(2) è una estensione della funzione system(3). Infatti, execve(2) può
                    eseguire un qualsiasi programma, incluso uno script di shell.</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="64">
            <legend>64. Supponiamo di aver mappato un file in memoria con la system call mmap(2). A cosa serve invocare
                la msync(2)?
            </legend>

            <div>
                <input type="radio" id="65_0" name="65" class="correct">
                <label for="65_0">Impostando il tipo di mapping a MAP_SHARED la msync(2) permette di scrivere le
                    modifiche su disco prima dell' invocazione di una unmap(2) o prima della chiusura del file
                    descriptor. </label>
            </div>


            <div>
                <input type="radio" id="65_1" name="65">
                <label for="65_1">è necessario invocare sempre la msync(2) se non si vogliono perdere le modifiche fatte
                    in memoria.</label>
            </div>


            <div>
                <input type="radio" id="65_2" name="65">
                <label for="65_2">non serve invocare la mysinc perchè quando si chiude il file descriptor tutte le
                    modifiche fatte in memoria vengono scritte su disco</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="65">
            <legend>65. Quale delle seguenti affermazioni sui processi Linux è falsa?
            </legend>

            <div>
                <input type="radio" id="66_0" name="66">
                <label for="66_0">In un determinato istante, non possono esserci 2 processi distinti con lo stesso
                    PID</label>
            </div>


            <div>
                <input type="radio" id="66_1" name="66" class="correct">
                <label for="66_1">Per creare i PID dei processi si usano dei numeri interi che crescono sempre</label>
            </div>


            <div>
                <input type="radio" id="66_2" name="66">
                <label for="66_2">In istanti diversi, possono esserci 2 processi distinti con lo stesso PID</label>
            </div>


            <div>
                <input type="radio" id="66_3" name="66">
                <label for="66_3">Ogni processo può conoscere il suo PID</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="66">
            <legend>66. Quale delle seguenti affermazioni sui processi Linux è vera?
            </legend>

            <div>
                <input type="radio" id="67_0" name="67">
                <label for="67_0">Normalmente, il processo figlio, una volta terminata la sua computazione, attende, con
                    una chiamata alla syscall wait, che il padre termini e gli restituisca il suo exit status</label>
            </div>


            <div>
                <input type="radio" id="67_1" name="67">
                <label for="67_1">Un processo diventa zombie se termina prima di almeno uno dei processi che abbia
                    eventualmente creato</label>
            </div>


            <div>
                <input type="radio" id="67_2" name="67">
                <label for="67_2">Ogni processo può conoscere il proprio PID, ma non quello del processo che l'ha
                    creato</label>
            </div>


            <div>
                <input type="radio" id="67_3" name="67" class="correct">
                <label for="67_3">Con l'eccezione del primo processo, tutti i processi sono creati con una fork</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="67">
            <legend>67. Quale delle seguenti affermazioni sui processi Linux è falsa?
            </legend>

            <div>
                <input type="radio" id="68_0" name="68" class="correct">
                <label for="68_0">Digitare un comando sulla shell genera sempre un nuovo processo</label>
            </div>


            <div>
                <input type="radio" id="68_1" name="68">
                <label for="68_1">Esistono file che non possono essere eseguiti per diventare processi</label>
            </div>


            <div>
                <input type="radio" id="68_2" name="68">
                <label for="68_2">Affinché un file possa diventare un processo è necessario che abbia i permessi di
                    esecuzione</label>
            </div>


            <div>
                <input type="radio" id="68_3" name="68">
                <label for="68_3">Qualsiasi computazione eseguita dal sistema operativo è contenuta dentro un qualche
                    processo</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="68">
            <legend>68. Quale delle seguenti affermazioni sui processi Linux è vera?
            </legend>

            <div>
                <input type="radio" id="69_0" name="69" class="correct">
                <label for="69_0">Eseguendo k volte un file eseguibile, si generano k diversi processi</label>
            </div>


            <div>
                <input type="radio" id="69_1" name="69">
                <label for="69_1">Per poter lanciare un file eseguibile, è prima necessario aspettare che il comando
                    precedente sia terminato</label>
            </div>


            <div>
                <input type="radio" id="69_2" name="69">
                <label for="69_2">Tutti i processi sono sempre in stato di RUNNING</label>
            </div>


            <div>
                <input type="radio" id="69_3" name="69">
                <label for="69_3">Un processo è sempre un'istanza di uno script bash</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="69">
            <legend>69. Un programma scritto in linguaggio C:
            </legend>

            <div>
                <input type="radio" id="70_0" name="70">
                <label for="70_0">Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere
                    ‘</label>
            </div>

            <br>
            ’
            </legend>

            <div>
                <input type="radio" id="70_1" name="70">
                <label for="70_1">Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere
                    ‘^M’</label>
            </div>


            <div>
                <input type="radio" id="70_2" name="70">
                <label for="70_2">Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere
                    ‘0’</label>
            </div>


            <div>
                <input type="radio" id="70_3" name="70" class="correct">
                <label for="70_3">Rappresenta le stringhe come array di caratteri terminate dal carattere ‘ ’</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="70">
            <legend>70. Quale delle seguenti affermazioni è vera?
            </legend>

            <div>
                <input type="radio" id="71_0" name="71">
                <label for="71_0">Linus Torvalds ha riscritto i pacchetti di Unix, creando i pacchetti GNU</label>
            </div>


            <div>
                <input type="radio" id="71_1" name="71">
                <label for="71_1">Tutte le opzioni sono false</label>
            </div>


            <div>
                <input type="radio" id="71_2" name="71">
                <label for="71_2">Linus Torvalds ha scritto il primo kernel di Linux all'inizio degli anni '80</label>
            </div>


            <div>
                <input type="radio" id="71_3" name="71" class="correct">
                <label for="71_3">Richard Stallman ha descritto per primo la licenza GPL</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="71">
            <legend>71. Quali delle seguenti affermazioni è vera?
            </legend>

            <div>
                <input type="radio" id="72_0" name="72">
                <label for="72_0">A. Nessuna delle opzioni è vera</label>
            </div>


            <div>
                <input type="radio" id="72_1" name="72">
                <label for="72_1">È possibile montare un filesystem solo se è dichiarato nel file /etc/fstab</label>
            </div>


            <div>
                <input type="radio" id="72_2" name="72" class="correct">
                <label for="72_2">È possibile montare un filesystem solo se è dichiarato nel file /etc/mtab</label>
            </div>


            <div>
                <input type="radio" id="72_3" name="72">
                <label for="72_3">D. Ad ogni filesystem corrisponde un disco fisico o parte di esso (partizione)</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="72">
            <legend>72. Si supponga di avere il seguente frammento di codice:
                <br>
                <code>FILE *stream = fopen(NOMEFILE, "w");</code>
                <br>
                Quale dei seguenti frammenti di codice ha lo stesso effetto?
            </legend>

            <div>
                <input type="radio" id="73_0" name="73">
                <label for="73_0"><code>int fd = open(NOMEFILE, O_WRONLY | O_CREAT, 0666);</code></label>
            </div>


            <div>
                <input type="radio" id="73_1" name="73">
                <label for="73_1"><code>int fd = open(NOMEFILE, O_WRONLY | O_TRUNC);</code></label>
            </div>


            <div>
                <input type="radio" id="73_2" name="73">
                <label for="73_2"><code>int fd = open(NOMEFILE, O_WRONLY);</code></label>
            </div>


            <div>
                <input type="radio" id="73_3" name="73" class="correct">
                <label for="73_3"><code>int fd = open(NOMEFILE, O_WRONLY | O_CREAT | O_TRUNC, 0666);</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="73">
            <legend>73. 10. (questa domanda ha una crisi d'identità) Quale delle seguenti affermazioni sulle syscall di
                Linux che riguardano i files è falsa?
            </legend>

            <div>
                <input type="radio" id="74_0" name="74">
                <label for="74_0">Chiamando la syscall select, è possibile monitorare un insieme di file descriptor, ed
                    essere notificati non appena ce n'è uno che è diventato disponibile per un'operazione di lettura o
                    scrittura</label>
            </div>


            <div>
                <input type="radio" id="74_1" name="74" class="correct">
                <label for="74_1">Per richiedere un lock su un file (o su una porzione di esso), occorre chiamare la
                    syscall ioctl</label>
            </div>


            <div>
                <input type="radio" id="74_2" name="74">
                <label for="74_2">È possibile usare la syscall select sia in modo bloccante che in modo non
                    bloccante</label>
            </div>


            <div>
                <input type="radio" id="74_3" name="74">
                <label for="74_3">Le syscall ioctl e fcntl ammettono 2 o 3 argomenti, a seconda dell'operazione</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="74">
            <legend>74. 11. (☢ UNSAFE, segnalate a @notherealmarco se è corretta o meno 🙏) Quale delle seguenti
                affermazioni sui segnali Linux è vera?
            </legend>

            <div>
                <input type="radio" id="75_0" name="75">
                <label for="75_0">Tutti i segnali, se non opportunamente catturati, provocano la terminazione del
                    processo, con l'eccezione del segnale STOP</label>
            </div>


            <div>
                <input type="radio" id="75_1" name="75">
                <label for="75_1">Per un processo è sempre possibile ridefinire il comportamento di un qualsiasi
                    segnale</label>
            </div>


            <div>
                <input type="radio" id="75_2" name="75">
                <label for="75_2">È possibile per un qualunque processo inviare un segnale ad un qualsiasi altro
                    processo dello stesso utente</label>
            </div>


            <div>
                <input type="radio" id="75_3" name="75" class="correct">
                <label for="75_3">Nessuna delle altre affermazioni è vera</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="75">
            <legend>75. 12. Quale delle seguenti affermazioni sugli errori delle syscall di Linux è vera?
            </legend>

            <div>
                <input type="radio" id="76_0" name="76">
                <label for="76_0">Per stampare su stderr la spiegazione di un errore verificatosi in una syscall, il cui
                    nome sia contenuto nella variabile syscall_name (di tipo char *), si può effettuare la seguente
                    chiamata: perror("Si è verificato il seguente errore nella chiamata a %s", syscall_name);</label>
            </div>


            <div>
                <input type="radio" id="76_1" name="76" class="correct">
                <label for="76_1">Per stampare su stdout la spiegazione di un errore verificatosi in una syscall si può
                    effettuare la seguente chiamata: printf("%s</label>
            </div>

            <br>
            ", strerror(errno));
            </legend>

            <div>
                <input type="radio" id="76_2" name="76">
                <label for="76_2">Per stampare su stdout la spiegazione di un errore verificatosi in una syscall è
                    sufficiente chiamare perror</label>
            </div>


            <div>
                <input type="radio" id="76_3" name="76">
                <label for="76_3">Per stampare su stdout la spiegazione di un errore verificatosi in una syscall è
                    necessario scrivere uno switch sulla variabile globale errno</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="76">
            <legend>76. (☢ Ce ne sono due che sono letteralmente uguali, quindi non so cosa si sia 🚬 il prof.
                Rispondete con la prima delle due) Si supponga di avere il seguente frammento di codice:
                <br>
                FILE *stream = fopen("file_esistente.txt", "r");
                <br>
                fseek(stream, -100, SEEK_END);
                <br>
                long pos = ftell(stream);
                <br>
                Quale dei seguenti frammenti di codice ha lo stesso effetto?
                <br>
                a.
                <pre>
<br>
int fd = open("file_esistente.txt", O_RDONLY);
<br>
lseek(fd, -100, SEEK_END);
<br>
long pos = lseek(fd, 0, SEEK_END);
<br>
</pre>
                <br>
                b.
                <pre>
<br>
int fd = open("file_esistente.txt", O_RDONLY);
<br>
lseek(fd, -100, SEEK_END);
<br>
long pos = lseek(fd, 0, SEEK_CUR);
<br>
</pre>
                <br>
                c.
                <pre>
<br>
int fd = open("file_esistente.txt", O_RDONLY);
<br>
lseek(fd, -100, SEEK_END);
<br>
long pos = lseek(fd, -100, SEEK_END);
<br>
</pre>
                <br>
                d.
                <pre>
<br>
int fd = open("file_esistente.txt", O_RDONLY);
<br>
lseek(fd, -100, SEEK_END);
<br>
long pos = ltell(fd);
<br>
</pre>
            </legend>

            <div>
                <input type="radio" id="77_0" name="77">
                <label for="77_0">a</label>
            </div>


            <div>
                <input type="radio" id="77_1" name="77" class="correct">
                <label for="77_1">b</label>
            </div>


            <div>
                <input type="radio" id="77_2" name="77">
                <label for="77_2">c</label>
            </div>


            <div>
                <input type="radio" id="77_3" name="77">
                <label for="77_3">d</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="77">
            <legend>76. Si consideri la seguente funzione <code>f</code>
                <br>
                <pre>
<br>
char *f(char *dest, const char *src, size_t n) {
<br>
    size_t i;
<br>
    for (i = 0; i < n && src[i] != ' '; i++)
<br>
        dest[i] = src[i];
<br>
for ( ; i < n; i++)
<br>
dest[i] = ' ';
<br>
return dest;
<br>
}
<br>
</pre>
                <br>
                Cosa produce come risultato quando eseguita?
            </legend>

            <div>
                <input type="radio" id="78_0" name="78">
                <label for="78_0">Genera sempre errore in fase di esecuzione perché non c'è alcun controllo sulla
                    dimensione delle stringhe</label>
            </div>


            <div>
                <input type="radio" id="78_1" name="78">
                <label for="78_1">Concatena la stringa src a dest e restituisce dest</label>
            </div>


            <div>
                <input type="radio" id="78_2" name="78" class="correct">
                <label for="78_2">Copia la stringa src in dest e restituisce dest</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="78">
            <legend>77. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
sigset_t set, oset, pset;
<br>
...
<br>
sigemptyset( &set );
<br>
sigaddset( &set, SIGINT );
<br>
sigaddset( &set, SIGUSR1 );
<br>
sigprocmask( SIG_BLOCK, &set, &oset );
<br>
...
<br>
</pre>
            </legend>

            <div>
                <input type="radio" id="79_0" name="79" class="correct">
                <label for="79_0">Prepara una sezione critica (ovvero dopo la sigprocmask può inizare la sezione
                    critica)</label>
            </div>


            <div>
                <input type="radio" id="79_1" name="79">
                <label for="79_1">Disabilita tutti i segnali tranne SIGINT e SIGUSR1</label>
            </div>


            <div>
                <input type="radio" id="79_2" name="79">
                <label for="79_2">Termina una sezione critica precedentemente iniziata</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="79">
            <legend>78. Sia mylink un hard link al file myfile (<code>ln myfile mylink</code>).
                <br>
                Quale di queste afferrmazioni è vera?
            </legend>

            <div>
                <input type="radio" id="80_0" name="80">
                <label for="80_0">myfile e mylink hanno dimensione diversa</label>
            </div>


            <div>
                <input type="radio" id="80_1" name="80" class="correct">
                <label for="80_1">myfile e mylink hanno lo stesso numero di inode</label>
            </div>


            <div>
                <input type="radio" id="80_2" name="80">
                <label for="80_2">myfile e mylink hanno un diverso numero di inode</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="80">
            <legend>79. Supponendo di essere "loggato" in una shell come utente1.
                <br>
                Quali dei seguenti è un path assoluto?
            </legend>

            <div>
                <input type="radio" id="81_0" name="81">
                <label for="81_0">dir1/dir11/dir112/filename</label>
            </div>


            <div>
                <input type="radio" id="81_1" name="81" class="correct">
                <label
                    for="81_1"><code>~/utente1/dir1/dir11/dir112/filename oppure ~/dir1/dir11/dir112/filename</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="81">
            <legend>80. Si supponga che nel sistema esiste un gruppo "studente".
                <br>
                Si supponga di voler creare "utente1" e di volerlo aggiungere al gruppo studente.
                <br>
                Quale dei seguenti comandi è corrretto?
            </legend>

            <div>
                <input type="radio" id="82_0" name="82" class="correct">
                <label for="82_0"><code>adduser utente1; adduser utente1 studente</code></label>
            </div>


            <div>
                <input type="radio" id="82_1" name="82">
                <label for="82_1"><code>adduser utente1 utente1 studente</code></label>
            </div>


            <div>
                <input type="radio" id="82_2" name="82">
                <label for="82_2"><code>adduser utente1 studente</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="82">
            <legend>81. Si considerino le seguenti dichiarazioni di variabili:
                <br>
                <pre>
<br>
int vect[10];
<br>
int *ptr = NULL;
<br>
</pre>
                <br>
                Quale delle seguneti assegnazioni è corretta per far sì che ptr contanga il puntatore al vettore vect?
            </legend>

            <div>
                <input type="radio" id="83_0" name="83" class="correct">
                <label for="83_0">ptr = vect;</label>
            </div>


            <div>
                <input type="radio" id="83_1" name="83">
                <label for="83_1">ptr = &vect</label>
            </div>


            <div>
                <input type="radio" id="83_2" name="83">
                <label for="83_2">ptr = vect[1];</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="83">
            <legend>82. Si supponda di avere 2 file hw1.c e hw2.c contenenti il seguente codice
                <br>
                <pre>
<br>
hw1.c:
<br>
#include <stdio.h>
<br>
#include "hw.2.c"
<br>
int f(int argc, char *args[]) {
<br>
printf("Hello World!
<br>
");
<br>
return 256;
<br>
}
<br>
</pre>
                <br>
                <pre>
<br>
hw2.c:
<br>
int f(int argc, char *args[]);
<br>
int main(int argc, char *args[]) {
<br>
return f(argc, args);
<br>
}
<br>
</pre>
                <br>
                Quale dei seguneti comandi di compilazione non genera errore?
            </legend>

            <div>
                <input type="radio" id="84_0" name="84" class="correct">
                <label for="84_0"><code>gcc -Wall hw1.c hw2.c -o hw.out</code> oppure
                    <code>gcc -Wall hw1.c -o hw.out</code></label>
            </div>


            <div>
                <input type="radio" id="84_1" name="84">
                <label for="84_1"><code>gcc -Wall hw2.c -o hw.out</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="84">
            <legend>83. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
pid_t pID = fork();
<br>
if (pID == 0) {
<br>
    Blocco_1
<br>
} else if (pID < 0) {
<br>
    Blocco_2
<br>
} else {
<br>
    Blocco_3
<br>
}
<br>
</pre>
                <br>
                Quale blocco di codice (tra Bloccco_1, Blocco_2 e Blocco_3) verrà eseguito nel caso in cui la fork non
                vada a buon fine?
            </legend>

            <div>
                <input type="radio" id="85_0" name="85">
                <label for="85_0">Blocco_1</label>
            </div>


            <div>
                <input type="radio" id="85_1" name="85">
                <label for="85_1">Blocco_3</label>
            </div>


            <div>
                <input type="radio" id="85_2" name="85" class="correct">
                <label for="85_2">Blocco_2</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="85">
            <legend>84. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
for (i=0;((i<n1)&&(i<n2));i++)
<br>
    m2[i]=m1[i];
<br>
</pre>
                <br>
                quando termina il ciclo for?
            </legend>

            <div>
                <input type="radio" id="86_0" name="86">
                <label for="86_0">Termina solo se n1 è uguale a n2</label>
            </div>


            <div>
                <input type="radio" id="86_1" name="86">
                <label for="86_1">Quando si raggiunge il più grande tra n1 e n2</label>
            </div>


            <div>
                <input type="radio" id="86_2" name="86" class="correct">
                <label for="86_2">Quando si raggiunge il più piccolo tra n1 e n2</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="86">
            <legend>85. A seguito di una chiamata a fork(2), quale dei seguenti attributi del processo padre non è
                ereditato dal processo figlio?
            </legend>

            <div>
                <input type="radio" id="87_0" name="87">
                <label for="87_0">groups id</label>
            </div>


            <div>
                <input type="radio" id="87_1" name="87" class="correct">
                <label for="87_1">coda dei segnali</label>
            </div>


            <div>
                <input type="radio" id="87_2" name="87">
                <label for="87_2">descrittori dei file</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="87">
            <legend>86. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
struct stat *s;
<br>
fd=open(“filename");
<br>
fchmod(fd,00744);
<br>
fstat(fd,s);
<br>
</pre>
                <br>
                Per visualizzare su sdtout i permessi di accesso a "filename", quale tra le seguenti opzioni è la più
                appropriata?
            </legend>

            <div>
                <input type="radio" id="88_0" name="88">
                <label for="88_0"><code>printf("New File mode %x</label>
            </div>
        
<br>
", s.st_mode);</code>
                    </legend>

                    <div>
                        <input type="radio" id="88_1" name="88" class="correct">
                        <label for="88_1"><code>printf("New File mode %o</label>
            </div>
        
<br>
", s.st_mode);</code>
                            </legend>

                            <div>
                                <input type="radio" id="88_2" name="88">
                                <label for="88_2"><code>printf("New File mode %s</label>
            </div>
        
<br>
", s.st_mode);</code>
        </fieldset>
        <br>

        <fieldset id="88">
            <legend>87. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
int n=2;
<br>
int r=2 * (n++);
<br>
</pre>
                <br>
                <pre>
<br>
int n=2;
<br>
int r1=2 * (++n);
<br>
</pre>
                <br>
                Quale valori assumeranno le variabili r e r1 dopo l'esecuzione?
            </legend>

            <div>
                <input type="radio" id="89_0" name="89">
                <label for="89_0">r = r1 = 4</label>
            </div>


            <div>
                <input type="radio" id="89_1" name="89">
                <label for="89_1">r=6 e r1=4</label>
            </div>


            <div>
                <input type="radio" id="89_2" name="89" class="correct">
                <label for="89_2">r=4 e r1=6</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="89">
            <legend>88. Supponiamo di avere la seguenti variabili
                <br>
                <code>int x=1, y=7;</code>
                <br>
                Quale delle seguneti espressioni è falsa?
            </legend>

            <div>
                <input type="radio" id="90_0" name="90" class="correct">
                <label for="90_0"><code>(x & y) == 7</code></label>
            </div>


            <div>
                <input type="radio" id="90_1" name="90">
                <label for="90_1"><code>(x | y) == 7</code></label>
            </div>


            <div>
                <input type="radio" id="90_2" name="90">
                <label for="90_2"><code>(x || y) == (x & y)</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="90">
            <legend>89. Per visualizzare l’atime di un file quale dei seguenti comandi è corretto?
            </legend>

            <div>
                <input type="radio" id="91_0" name="91">
                <label for="91_0"><code>ls -lc nomefile</code></label>
            </div>


            <div>
                <input type="radio" id="91_1" name="91" class="correct">
                <label for="91_1"><code>ls -lu nomefile</code></label>
            </div>


            <div>
                <input type="radio" id="91_2" name="91">
                <label for="91_2"><code>ls -la nomefile</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="91">
            <legend>90. Quali attributi del processo sono preservati dalla funzione di libreria execve()?
            </legend>

            <div>
                <input type="radio" id="92_0" name="92">
                <label for="92_0">Memory locks</label>
            </div>


            <div>
                <input type="radio" id="92_1" name="92">
                <label for="92_1">Timer</label>
            </div>


            <div>
                <input type="radio" id="92_2" name="92" class="correct">
                <label for="92_2">Umask</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="92">
            <legend>91. I permessi di accesso del file eseguibile <code>/usr/bin/passwd</code> sono
                <code>4755/-rwsr-xr-x</code>
                <br>
                Cosa significa?
            </legend>

            <div>
                <input type="radio" id="93_0" name="93">
                <label for="93_0">Il bit SetUid non è settato</label>
            </div>


            <div>
                <input type="radio" id="93_1" name="93">
                <label for="93_1">Lo sticky bit è settato</label>
            </div>


            <div>
                <input type="radio" id="93_2" name="93" class="correct">
                <label for="93_2">Il bit SetUid è settato</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="93">
            <legend>92. Si assuma di avere due shell aperte, etichettate come shell_1 e shell_2 e si consideri la
                seguente sequenza di comandi
                <br>
                (shell_i:cmd indica che cmd è eseguitto nella shell i, i=1,2).
                <br>
                <pre>
<br>
shell_1: xterm
<br>
shell_2: ps -C xterm
<br>
#restituisce xtermPID
<br>
shell_2: kill -s SIGINT xtermPID
<br>
</pre>
                <br>
                Quale è il loro effetto?
            </legend>

            <div>
                <input type="radio" id="94_0" name="94">
                <label for="94_0">Il processo xterm viene messo nello stato stopped (T)</label>
            </div>


            <div>
                <input type="radio" id="94_1" name="94" class="correct">
                <label for="94_1">Il processo xterm viene terminato con segnale SIGINT</label>
            </div>


            <div>
                <input type="radio" id="94_2" name="94">
                <label for="94_2">Il processo xterm viene messo in background</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="94">
            <legend>93. Supponiamo di aver dichiarato ed inizializzato le seguenti variabili
                <br>
                <code>int x = 1, y = 7;</code>
                <br>
                Quale delle seguenti espressioni è vera (true)?
            </legend>

            <div>
                <input type="radio" id="95_0" name="95" class="correct">
                <label for="95_0">(x & y) == (x && y)</label>
            </div>


            <div>
                <input type="radio" id="95_1" name="95">
                <label for="95_1">(x && y) == 7</label>
            </div>


            <div>
                <input type="radio" id="95_2" name="95">
                <label for="95_2">(x & y) == (x | y)</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="95">
            <legend>94. Si consideri la seguente funzione fa
                <br>
                <pre>
<br>
char *f(char *dest, const char *src, size_t n) {
<br>
    size_t dest_len = strlen(dest);
<br>
    size_t i;
<br>
    for (i = 0; i < n && src[i] != ' '; i++)
<br>
        dest[dest_len + i] = src[i];
<br>
    dest[dest_len + i] = ' ';
<br>
return dest;
<br>
}
<br>
</pre>
            </legend>

            <div>
                <input type="radio" id="96_0" name="96">
                <label for="96_0">Copia la stringa src in dest e restituisce dest</label>
            </div>


            <div>
                <input type="radio" id="96_1" name="96" class="correct">
                <label for="96_1">Concatena la stringa src a dest e restituisce dest</label>
            </div>


            <div>
                <input type="radio" id="96_2" name="96">
                <label for="96_2">Genera sempre errore in fase di esecuzione perché non c'è alcun controllo sulla
                    dimensione delle stringhe</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="96">
            <legend>95. Si supponga di avere un file di testo (filein) e di voler copiare in un altro file (fileout) 100
                caratteri a partire dal decimo.
                <br>
                Quale di questi comandi è corretto?
            </legend>

            <div>
                <input type="radio" id="97_0" name="97">
                <label for="97_0"><code>cp -n10 -i100 filein fileout</code></label>
            </div>


            <div>
                <input type="radio" id="97_1" name="97" class="correct">
                <label for="97_1"><code>dd if=filein of=fileout bs=1 skip=10 count=100</code></label>
            </div>


            <div>
                <input type="radio" id="97_2" name="97">
                <label for="97_2"><code>dd if=filein of=fileout bs=100 skip=10 count = 1</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="97">
            <legend>96. Sia mylink un soft link al file myfile (<code>ln -s myfile mylink</code>).
                <br>
                Quale di queste affermazioni è vera?
            </legend>

            <div>
                <input type="radio" id="98_0" name="98" class="correct">
                <label for="98_0">myfile e mylink hanno un diverso numero di inode</label>
            </div>


            <div>
                <input type="radio" id="98_1" name="98">
                <label for="98_1">myfile e mylink hanno lo stesso numero di inode</label>
            </div>


            <div>
                <input type="radio" id="98_2" name="98">
                <label for="98_2">myfile e mylink hanno la stessa dimensione</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="98">
            <legend>97. Si consideri il codice
                <br>
                <pre>
<br>
struct stat *s;
<br>
fd = open("filename");
<br>
fstat(fs, s);
<br>
</pre>
                <br>
                Come faccio a sapere se il file "filename" è un link?
            </legend>

            <div>
                <input type="radio" id="99_0" name="99" class="correct">
                <label for="99_0">Se S_ISLINK(s) == 1</label>
            </div>


            <div>
                <input type="radio" id="99_1" name="99">
                <label for="99_1">Se s.st_size == 0</label>
            </div>


            <div>
                <input type="radio" id="99_2" name="99">
                <label for="99_2">Se s_st_nlink == 1</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="99">
            <legend>98. Quale tra i seguenti comandi è il modo più corretto per verificare a quali gruppi appartiene un
                utente?
            </legend>

            <div>
                <input type="radio" id="100_0" name="100">
                <label for="100_0"><code>groups nomeutente</code></label>
            </div>


            <div>
                <input type="radio" id="100_1" name="100">
                <label for="100_1"><code>cat /etc/groups | grep nomeutente</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="100">
            <legend>99. Cosa fa sto ciclo?
                <br>
                <code>for(scoreCount = 0; scanf("%d", &a) == 1; scoreCount++);</code>
            </legend>

            <div>
                <input type="radio" id="101_0" name="101" class="correct">
                <label for="101_0">Legge ripetutamente numeri interi da stdin</label>
            </div>


            <div>
                <input type="radio" id="101_1" name="101">
                <label for="101_1">Legge una sola volta da stdin e poi termina</label>
            </div>


            <div>
                <input type="radio" id="101_2" name="101">
                <label for="101_2">Legge da stdin senza mai terminare</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="101">
            <legend>100. Quale delle seguenti funzioni di libreria non alloca nell'heap?
            </legend>

            <div>
                <input type="radio" id="102_0" name="102">
                <label for="102_0">calloc</label>
            </div>


            <div>
                <input type="radio" id="102_1" name="102">
                <label for="102_1">malloc</label>
            </div>


            <div>
                <input type="radio" id="102_2" name="102" class="correct">
                <label for="102_2">alloca</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="102">
            <legend>101. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
sigset_t set, oset, pset;
<br>
...
<br>
sigemptyset( &set );
<br>
sigaddset( &set, SIGINT );
<br>
sigaddset( &set, SIGUSR1 );
<br>
sigprocmask( SIG_BLOCK, &set, &oset );
<br>
...
<br>
</pre>
            </legend>

            <div>
                <input type="radio" id="103_0" name="103">
                <label for="103_0">Termina una sezione critica precedentemente iniziata</label>
            </div>


            <div>
                <input type="radio" id="103_1" name="103">
                <label for="103_1">Disabilita tutti i segnali tranne SIGINT e SIGUSR1</label>
            </div>


            <div>
                <input type="radio" id="103_2" name="103" class="correct">
                <label for="103_2">Disabilita i segnali SIGINT e SIGUSR1</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="103">
            <legend>102. Per visualizzare contemporaneamente l'access time e status change time di un file, quale dei
                seguenti comandi è corretto?
            </legend>

            <div>
                <input type="radio" id="104_0" name="104" class="correct">
                <label for="104_0">stat nomefile</label>
            </div>


            <div>
                <input type="radio" id="104_1" name="104">
                <label for="104_1">ls -la nomefile</label>
            </div>


            <div>
                <input type="radio" id="104_2" name="104">
                <label for="104_2">ls -lac nomefile</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="104">
            <legend>103. Consideri il seguente frammento di codice
                <br>
                <pre>int *ptr = malloc(sizeof(int));
<br>
ptr = ptr+1;</pre>
                <br>
                assumendo la malloc assegni a ptr la locazione di memoria 0x55c2b1268420 cosa contiene ptr dopo
                l’incremento?
            </legend>

            <div>
                <input type="radio" id="105_0" name="105">
                <label for="105_0"><code>0x55c2b1268421</code></label>
            </div>


            <div>
                <input type="radio" id="105_1" name="105">
                <label for="105_1"><code>0x55c2b1268428</code></label>
            </div>


            <div>
                <input type="radio" id="105_2" name="105" class="correct">
                <label for="105_2"><code>0x55c2b1268424</code></label>
            </div>

        </fieldset>
        <br>

        <fieldset id="105">
            <legend>104. Che cosa si intende per sudoer nel gergo Linux?
            </legend>

            <div>
                <input type="radio" id="106_0" name="106">
                <label for="106_0">Un comando per essere aggiunti al gruppo sudo</label>
            </div>


            <div>
                <input type="radio" id="106_1" name="106">
                <label for="106_1">Un gruppo che permette ai suoi membri di eseguire comandi come super-utente</label>
            </div>


            <div>
                <input type="radio" id="106_2" name="106" class="correct">
                <label for="106_2">Un utente che appartiene al gruppo di utenti sudo</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="106">
            <legend>105. Assumiamo che quando viene creata una directory i suoi permessi di accesso sono 0644.
                <br>
                Quale sarà la umask?
            </legend>

            <div>
                <input type="radio" id="107_0" name="107">
                <label for="107_0">0644</label>
            </div>


            <div>
                <input type="radio" id="107_1" name="107">
                <label for="107_1">0022</label>
            </div>


            <div>
                <input type="radio" id="107_2" name="107" class="correct">
                <label for="107_2">0133</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="107">
            <legend>106. Se una directory ha i permessi di accesso settati come 0222, quali operazioni è possibile fare
                su di essa?
            </legend>

            <div>
                <input type="radio" id="108_0" name="108" class="correct">
                <label for="108_0">Nessuna operazione</label>
            </div>


            <div>
                <input type="radio" id="108_1" name="108">
                <label for="108_1">Operazioni di scrittura ed e possibile visualizzarne il contenuto senza vedere gli
                    attributi dei file</label>
            </div>


            <div>
                <input type="radio" id="108_2" name="108">
                <label for="108_2">Operazioni di scrittura</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="108">
            <legend>107. Assumete di voler visualizzare il numero di inode di un file, quale dei seguenti comandi è più
                corretto usare?
            </legend>

            <div>
                <input type="radio" id="109_0" name="109">
                <label for="109_0">ls -l -n nomefile</label>
            </div>


            <div>
                <input type="radio" id="109_1" name="109">
                <label for="109_1">stat -f nomefile</label>
            </div>


            <div>
                <input type="radio" id="109_2" name="109" class="correct">
                <label for="109_2">ls -1 -i nomefile</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="109">
            <legend>108. Quando si esegue il comando ls -l viene mostrato, come prima informazione, il totale (vedi
                figura, ma non sul bot :p)
                <br>
                Quale è il significato di questo campo?
            </legend>

            <div>
                <input type="radio" id="110_0" name="110" class="correct">
                <label for="110_0">Dimensione della directory espressa in numero di blocchi su disco</label>
            </div>


            <div>
                <input type="radio" id="110_1" name="110">
                <label for="110_1">Dimensione della directory espressa in numero di file contenuti in essa e in tutte le
                    sotto-directory</label>
            </div>


            <div>
                <input type="radio" id="110_2" name="110">
                <label for="110_2">Numero totale di sotto directory</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="110">
            <legend>109. Si consideri il seguente frammento di codice:
                <br>
                <pre>
<br>
int num = 5;
<br>
int *numPtr;
<br>
numPtr = &num;
<br>
*numPtr = 10;
<br>
</pre>
                <br>
                Dopo la sua esecuzione, quale sara' il valore contenuto il num ?
            </legend>

            <div>
                <input type="radio" id="111_0" name="111">
                <label for="111_0">5</label>
            </div>


            <div>
                <input type="radio" id="111_1" name="111" class="correct">
                <label for="111_1">10</label>
            </div>


            <div>
                <input type="radio" id="111_2" name="111">
                <label for="111_2">0x123AF345 (indirizzo di memoria)</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="111">
            <legend>110. Si consideri il seguente frammento di codice:
                <br>
                <pre>
<br>
int n= 2;
<br>
int r= 2*(n++); // r = 2 * 2, n = 3
<br>
int r1= 2*(++n); // n = 3 + 1, r1 = 2 * 4
<br>
</pre>
                <br>
                Quale delle seguenti espressioni sarà vera (true) una volta eseguito il codice?
            </legend>

            <div>
                <input type="radio" id="112_0" name="112" class="correct">
                <label for="112_0">r < r1</label>
            </div>


            <div>
                <input type="radio" id="112_1" name="112">
                <label for="112_1">r > r1</label>
            </div>


            <div>
                <input type="radio" id="112_2" name="112">
                <label for="112_2">r == r1</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="112">
            <legend>112. Si consideri il comando
                <br>
                <code>gcc -c file.c -o file.o</code>
                <br>
                Quali delle seguenti affermazioni e' falsa?
            </legend>

            <div>
                <input type="radio" id="113_0" name="113">
                <label for="113_0">Il comando produce un file oggetto a partire da un file precompilato</label>
            </div>


            <div>
                <input type="radio" id="113_1" name="113">
                <label for="113_1">Il comando produce un file oggetto</label>
            </div>


            <div>
                <input type="radio" id="113_2" name="113" class="correct">
                <label for="113_2">Il comando produce un file eseguibile</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="113">
            <legend>113. Cosa produce il seguente comando?
                <br>
                <code>gcc file.o file2.o file3.o</code>
            </legend>

            <div>
                <input type="radio" id="114_0" name="114" class="correct">
                <label for="114_0">Un file eseguibile a.out</label>
            </div>


            <div>
                <input type="radio" id="114_1" name="114">
                <label for="114_1">Nulla, la sintassi è sbagliata</label>
            </div>


            <div>
                <input type="radio" id="114_2" name="114">
                <label for="114_2">Fa il linking dei file oggetto ma non produce nessun risultato finché non si
                    specifica l'output</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="114">
            <legend>114. Si consideri il seguente frammento di codice. Cosa fa una volta eseguito?
                <br>
                <pre>
<br>
scanf("%d",&num);
<br>
while(num!=0); {
<br>
    printf("%d
<br>
",num);
<br>
    scanf("%d",&num);
<br>
}
<br>
</pre>
            </legend>

            <div>
                <input type="radio" id="115_0" name="115">
                <label for="115_0">stampa il valore di num almeno una volta</label>
            </div>


            <div>
                <input type="radio" id="115_1" name="115" class="correct">
                <label for="115_1">cicla infinitamente se num != 0</label>
            </div>


            <div>
                <input type="radio" id="115_2" name="115">
                <label for="115_2">stampa il valore di num se num != 0</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="115">
            <legend>115. Cosa produce il seguente comando come risultato?
                <br>
                <code>cat /etc/group | grep nomeutente</code>
            </legend>

            <div>
                <input type="radio" id="116_0" name="116" class="correct">
                <label for="116_0">Visualizza su stdout tutti i gruppi a cui appartiene l'utente "nomeutente", incluso
                    il gruppo "nomeutente" (se esiste)</label>
            </div>


            <div>
                <input type="radio" id="116_1" name="116">
                <label for="116_1">Visualizza su stdout la lista dei gruppi a cui appartiene il gruppo "nomeutente" (se
                    esiste)</label>
            </div>


            <div>
                <input type="radio" id="116_2" name="116">
                <label for="116_2">Genera un errore in quanto il file /etc/group non esiste</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="116">
            <legend>116. Nel caso in cui la system call <code>pid_t waitpid(pid_t pid, int *status, int options);</code>
                <br>
                sia invocata con valore di pid uguale a -1. Quale è il suo comportamento?
            </legend>

            <div>
                <input type="radio" id="117_0" name="117">
                <label for="117_0">Attende la terminazione di qualunque processo figlio il cui gruppo ID del processo
                    sia diverso da quello del processo chiamante</label>
            </div>


            <div>
                <input type="radio" id="117_1" name="117" class="correct">
                <label for="117_1">Attende la terminazione di un qualunque processo figlio</label>
            </div>


            <div>
                <input type="radio" id="117_2" name="117">
                <label for="117_2">Attende la terminazione di qualunque processo figlio il cui gruppo ID del processo
                    sia uguale a quello del processo chiamante</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="117">
            <legend>117. Quali dei seguenti comandi permette di creare un intero path di directory?
            </legend>

            <div>
                <input type="radio" id="118_0" name="118">
                <label for="118_0">mkdir /dir1/dir2/dir3</label>
            </div>


            <div>
                <input type="radio" id="118_1" name="118" class="correct">
                <label for="118_1">mkdir -p /dir1/dir2/dir3</label>
            </div>


            <div>
                <input type="radio" id="118_2" name="118">
                <label for="118_2">mkdir -m /dir1/dir2/dir3</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="118">
            <legend>118. Supponiamo di avere un file di nome filename e di creare un link a filename con il comando
                <br>
                <code>ln filename link1</code>
                <br>
                quale delle seguenti affermazioni è vera?
            </legend>

            <div>
                <input type="radio" id="119_0" name="119" class="correct">
                <label for="119_0">filename e link1 hanno lo stesso inode</label>
            </div>


            <div>
                <input type="radio" id="119_1" name="119">
                <label for="119_1">link1 occupa zero blocchi su disco anche se filename ne occupa un numero diverso da
                    0</label>
            </div>


            <div>
                <input type="radio" id="119_2" name="119">
                <label for="119_2">filename e link1 hanno inode diverso</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="119">
            <legend>119. Quali dei seguenti comandi change dir usa un path assoluto? (# indica il prompt di sistema)
            </legend>

            <div>
                <input type="radio" id="120_0" name="120">
                <label for="120_0"># cd ../studente/download</label>
            </div>


            <div>
                <input type="radio" id="120_1" name="120">
                <label for="120_1"># cd Immagini/../Immagini/faces/</label>
            </div>


            <div>
                <input type="radio" id="120_2" name="120" class="correct">
                <label for="120_2"># cd ~/Lezione1/esempi/filesystem</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="120">
            <legend>120. Quali sono i permessi MINIMI che devono essere assegnati ad una directory affinche' sia
                possibile:
                <br>
                - leggere il contenuto della directory inclusi gli attributi dei file;
                <br>
                - impostare la directory come cwd;
                <br>
                - attraversare la directory.
            </legend>

            <div>
                <input type="radio" id="121_0" name="121">
                <label for="121_0">rwx</label>
            </div>


            <div>
                <input type="radio" id="121_1" name="121" class="correct">
                <label for="121_1">r-x</label>
            </div>


            <div>
                <input type="radio" id="121_2" name="121">
                <label for="121_2">rw-</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="121">
            <legend>121. Supponiamo di avere il seguente makefile (memorizzato in un file di nome makefile):
                <br>
                <pre>
<br>
merge_sorted_lists: merge_sorted_lists.c
<br>
        gcc -Wall -Wextra -O3 merge_sorted_lists.c         -o merge_sorted_lists
<br>
sort_file_int: sort_file_int.c
<br>
        gcc -Wall -Wextra -O3 sort_file_int.c         -o sort_file_int
<br>
.PHONY: clean
<br>
clean:
<br>
        rm -f *.o merge_sorted_lists
<br>
</pre>
                <br>
                In quali condizioni viene eseguito il target sort_file_int?
            </legend>

            <div>
                <input type="radio" id="122_0" name="122">
                <label for="122_0">Sempre, se invochiamo il comando <code>make sort_file_int</code></label>
            </div>


            <div>
                <input type="radio" id="122_1" name="122" class="correct">
                <label for="122_1">Se invochiamo il comando <code>make sort_file_int</code>. e se sort_file_int.c e'
                    stato modificato dopo la data di creazione di sort_file_int.o</label>
            </div>


            <div>
                <input type="radio" id="122_2" name="122">
                <label for="122_2">Il target sort_file_int non verrà mai eseguito</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="122">
            <legend>122. SI consideri il seguente frammento di codice:
                <br>
                <pre>
<br>
int x, y, nread;
<br>
float xx, yy;
<br>
nread=scanf("%d %d",&x, &y);
<br>
printf("x=%d, y=%d, nread=%d 
<br>
",x,y,nread);
<br>
printf("xx=%f, yy=%f, nread=%d 
<br>
",xx,yy,nread);
<br>
nread=scanf("%f %f",&xx, &yy);
<br>
</pre>
                <br>
                Assumiamo che, in fase di esecuzione, la prima scanf legge su stdin la sequenza
                <br>
                <b>1 w</b>
                <br>
                Quale sara' il valore di nread dopo l'esecuzione della seconda scanf?
            </legend>

            <div>
                <input type="radio" id="123_0" name="123" class="correct">
                <label for="123_0">0</label>
            </div>


            <div>
                <input type="radio" id="123_1" name="123">
                <label for="123_1">2</label>
            </div>


            <div>
                <input type="radio" id="123_2" name="123">
                <label for="123_2">dipende dall'input letto su stdin dalla seconda scanf</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="123">
            <legend>123. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
 1: #include <stdio.h>
<br>
 2:  ....
<br>
 3: 
<br>
 4:  char str [80];
<br>
 5:  float f;
<br>
 6:  FILE * pFile;
<br>
 7:
<br>
 8:  pFile = fopen ("myfile.txt","w+");
<br>
 9:  fprintf (pFile, "%f %s
<br>
", 3.1416, "PI");
<br>
 10: close(pFile);
<br>
 11: rewind (pFile);
<br>
 12: fscanf (pFile, "%f", &f);
<br>
 13: fscanf (pFile, "%s", str);
<br>
</pre>
                <br>
                Le chiamate di funzione a riga 10, 11, 12 e 13 vengono eseguite tutte?
            </legend>

            <div>
                <input type="radio" id="124_0" name="124" class="correct">
                <label for="124_0">Sì</label>
            </div>


            <div>
                <input type="radio" id="124_1" name="124">
                <label for="124_1">Viene eseguita solo riga 10 poi genera errore ed il programma termina</label>
            </div>


            <div>
                <input type="radio" id="124_2" name="124">
                <label for="124_2">No, nessuna</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="124">
            <legend>124. Cosa fa il seguente segmento di codice?
                <br>
                <pre>
<br>
scanf(“%d”,&num); 
<br>
do {
<br>
printf(“%d
<br>
”,num); 
<br>
scanf(“%d”,&num);
<br>
} while(num!=0);
<br>
</pre>
            </legend>

            <div>
                <input type="radio" id="125_0" name="125">
                <label for="125_0">stampa il valore di num se num è diverso da 0</label>
            </div>


            <div>
                <input type="radio" id="125_1" name="125">
                <label for="125_1">Il ciclo do-while entra in un loop infinito</label>
            </div>


            <div>
                <input type="radio" id="125_2" name="125" class="correct">
                <label for="125_2">stampa il valore di num almeno una volta</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="125">
            <legend>125. Supponiamo di aver inizializzato un puntatore ad una variabile intera in questo modo
                <br>
                <pre>
<br>
int num=5, *ptrnum;
<br>
ptrnum=&num;
<br>
</pre>
            </legend>

            <div>
                <input type="radio" id="126_0" name="126">
                <label for="126_0">ptrnum = (int *) 10;</label>
            </div>


            <div>
                <input type="radio" id="126_1" name="126">
                <label for="126_1">ptrnum = 10;</label>
            </div>


            <div>
                <input type="radio" id="126_2" name="126" class="correct">
                <label for="126_2">*ptrnum = 10;</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="126">
            <legend>126. Quale dei seguenti dichiarazioni di variabile e' non valida, generando quindi un errore di
                compilazione?
            </legend>

            <div>
                <input type="radio" id="127_0" name="127" class="correct">
                <label for="127_0">int goto=1;</label>
            </div>


            <div>
                <input type="radio" id="127_1" name="127">
                <label for="127_1">int goTo=1;</label>
            </div>


            <div>
                <input type="radio" id="127_2" name="127">
                <label for="127_2">int go_to=1;</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="127">
            <legend>127. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
int scoreCount, a;        
<br>
for(scoreCount=0; scanf("%d",&a)==1; scoreCount++);
<br>
</pre>
                <br>
                Se la sequenza letta in input dall scanf è
                <br>
                <pre>
<br>
1 3 7 2 12 w
<br>
</pre>
                <br>
                Quale valore assumerà scoreCount al termine del ciclo?
            </legend>

            <div>
                <input type="radio" id="128_0" name="128">
                <label for="128_0">Il ciclo non termina. La scanf va in errore quando viene letta la w</label>
            </div>


            <div>
                <input type="radio" id="128_1" name="128" class="correct">
                <label for="128_1">5</label>
            </div>


            <div>
                <input type="radio" id="128_2" name="128">
                <label for="128_2">6</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="128">
            <legend>128. Si consideri il frammento di codice
                <br>
                <pre>
<br>
  int K=10, c=0, p=1;
<br>
  while (++K > 10)
<br>
    c=c+1;
<br>
  p--;
<br>
</pre>
                <br>
                che valore conterrà la variabile K al termine dell'esecuzione del frammento di codice?
            </legend>

            <div>
                <input type="radio" id="129_0" name="129">
                <label for="129_0">11</label>
            </div>


            <div>
                <input type="radio" id="129_1" name="129" class="correct">
                <label for="129_1">L'esecuziuone del frammento di codice non termina perche' Il ciclo entra in un loop
                    infinito</label>
            </div>


            <div>
                <input type="radio" id="129_2" name="129">
                <label for="129_2">10</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="129">
            <legend>129. In quale situazione le system call dup(2) e dup2(2) hanno lo stesso comportamento?
            </legend>

            <div>
                <input type="radio" id="130_0" name="130">
                <label for="130_0">Nel caso in cui gli passiamo gli stessi parametri</label>
            </div>


            <div>
                <input type="radio" id="130_1" name="130">
                <label for="130_1">Nel casa in cui invochiamo la dup2(2) settando a NULL il valore del nuovo file
                    descriptor</label>
            </div>


            <div>
                <input type="radio" id="130_2" name="130" class="correct">
                <label for="130_2">Nel caso in cui la dup2(2) venga invocata specificando che il nuovo file descriptor
                    deve essere il file descriptor disponibile con il numero più piccolo</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="130">
            <legend>130. Quali dei seguenti attributi di un processo non e' preservato a seguito di una chiamata alla
                funzione di libreria execve()?
            </legend>

            <div>
                <input type="radio" id="131_0" name="131">
                <label for="131_0">Groups id</label>
            </div>


            <div>
                <input type="radio" id="131_1" name="131" class="correct">
                <label for="131_1">Memory mapping</label>
            </div>


            <div>
                <input type="radio" id="131_2" name="131">
                <label for="131_2">File locks</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="131">
            <legend>131. Quale attributi di un processo non sono ereditati dal processo figlio?
            </legend>

            <div>
                <input type="radio" id="132_0" name="132">
                <label for="132_0">Descrittori dei file; terminale di controllo; memoria condivisa</label>
            </div>


            <div>
                <input type="radio" id="132_1" name="132" class="correct">
                <label for="132_1">I timer, i record lock e i memory lock; i contatori delle risorse </label>
            </div>


            <div>
                <input type="radio" id="132_2" name="132">
                <label for="132_2">Real ed effective user e group ID; working directory; ambiente del processo</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="132">
            <legend>132. Si consideri il seguente frammento di codice
                <br>
                <pre>
<br>
char* file = argv[1];
<br>
 int fd;
<br>
 struct flock lock;
<br>
 fd = open (file, O_WRONLY);
<br>
 memset (&lock, 0, sizeof(lock));
<br>
 lock.l_type = F_WRLCK; 
<br>
 fcntl (fd, F_GETLK, &lock);
<br>
</pre>
                <br>
                Quale è il comportamento della system call fcntl?
            </legend>

            <div>
                <input type="radio" id="133_0" name="133">
                <label for="133_0">Verifica se sul file file e' gia' presente un lock descritto dalla struttura lock.
                    Nel caso in cui nessun processo detiene un lock su file piazza il lock</label>
            </div>


            <div>
                <input type="radio" id="133_1" name="133" class="correct">
                <label for="133_1">Verifica se sul file file e' gia' presente un lock descritto dalla struttura lock.
                    Nel caso in cui nessun processo detiene un lock su file restituisce F_UNLOCK nel campo l_type di
                    lock</label>
            </div>


            <div>
                <input type="radio" id="133_2" name="133">
                <label for="133_2">Verifica se sul file file e' gia' presente un lock descritto dalla struttura lock. In
                    caso affermativo il lock viene rimosso ed il lock richiesto dal processo in esecuzione viene
                    piazzato</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="133">
            <legend>133. Un processo puo' allocare memoria solo nell'heap?
            </legend>

            <div>
                <input type="radio" id="134_0" name="134">
                <label for="134_0">Sì, mediante la funziona di libreria malloc(3) e calloc(3)</label>
            </div>


            <div>
                <input type="radio" id="134_1" name="134">
                <label for="134_1">Sì, mediante le funzioni di libreria malloc(3), calloc(3) e alloca(3)</label>
            </div>


            <div>
                <input type="radio" id="134_2" name="134" class="correct">
                <label for="134_2">No. Può allocare anche memoria nello stack mediante la funzione di libreria
                    alloca(3)</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="134">
            <legend>134. Supponiamo di aver utilizzato, nella nostra funzione C, la funzione di libreria alloca(3) per
                allocare un'area di memoria.
                <br>
                È necessario liberare tale area di memoria mediante una free(3) prima della terminazione della funzione?
            </legend>

            <div>
                <input type="radio" id="135_0" name="135" class="correct">
                <label for="135_0">No. l'area di memoria allocata nello stack viene liberata automaticamente</label>
            </div>


            <div>
                <input type="radio" id="135_1" name="135">
                <label for="135_1">Sì, ma mediante la chiamata di funzione dealloca(3) e non mediante la free(3)
                </label>
            </div>


            <div>
                <input type="radio" id="135_2" name="135">
                <label for="135_2">Sì, bisogna sempre liberare la memoria per evitare dei memory leak</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="135">
            <legend>135. Si consideri la variabile globale errno.
                <br>
                Se una system call termina con successo, e immediatamente dopo la sua terminazione ispezioniamo il
                contenuto di errno, cosa otteniamo?
            </legend>

            <div>
                <input type="radio" id="136_0" name="136">
                <label for="136_0">Il valore zero essendo la system call terminata con successo</label>
            </div>


            <div>
                <input type="radio" id="136_1" name="136">
                <label for="136_1">Il codice di terminazione (con successo) in quanto non c'è una effettiva differenza
                    tra codice di errore o di terminazione con successo</label>
            </div>


            <div>
                <input type="radio" id="136_2" name="136" class="correct">
                <label for="136_2">Il codice di errore generato dall'ultima system call o funzione di libreria la cui
                    esecuzione è terminata con errore</label>
            </div>

        </fieldset>
        <br>

        <fieldset id="136">
            <legend>136. Si consideri la system call
                <br>
                <code>
<br>
int open(const char *pathname, int flags);
<br>
</code>
                <br>
                nel caso venga invocata con il flag impostato a
                <br>
                <code>
<br>
O_CREAT | O_EXCL | O_WRONLY
<br>
</code>
                <br>
                Quale è il comportamento atteso?
            </legend>

            <div>
                <input type="radio" id="137_0" name="137" class="correct">
                <label for="137_0">Se il file non esiste viene creato ed aperto in scrittura, se invece esiste ritorna
                    errore</label>
            </div>


            <div>
                <input type="radio" id="137_1" name="137">
                <label for="137_1">Se il file non esiste viene creato con i permessi di esecuzione (x) ed aperto in
                    scrittura. Se esiste vengono aggiunti i permessi di esecuzione se già non settati ed il file è
                    aperto in scrittura</label>
            </div>


            <div>
                <input type="radio" id="137_2" name="137">
                <label for="137_2">Se il file non esiste lo crea e lo apre in scrittura, altrimenti lo apre in
                    lettura</label>
            </div>

        </fieldset> <input type="submit" value="Rispondi" onclick="checkAnswers()">
    </div>

    <script>
        const questionFields = document.querySelectorAll('#questions-form > fieldset');

        function checkAnswers() {
            let allCorrect = true;

            questionFields.forEach(fieldset => {
                const inputs = [...fieldset.querySelectorAll('input')];
                // Disable input
                inputs.forEach(input => input.disabled = true);

                const givenAnswer = inputs.find(input => input.checked);

                if (givenAnswer && givenAnswer.classList.contains('correct')) {
                    // Correct!
                    // Hide question from result
                    fieldset.remove();
                } else {
                    // Wrong!
                    allCorrect = false;
                    fieldset.classList.add('show-answer');
                    // Highlight given answer
                    if (givenAnswer) {
                        givenAnswer.classList.add('wrong');
                    }
                }
            });

            if (allCorrect) {
                alert('Tutte giuste, mostro!');
            } else {
                alert('Verranno mostrate le domande sbagliate o in bianco');
                window.scrollTo(0, 0);
            }
        }
    </script>
</body>

</html>